import { atomFamily, useAtomCallback } from 'jotai/utils';
import React, { createContext, useContext, useDebugValue, useState, useRef, useMemo, useEffect, useCallback, memo, forwardRef, useImperativeHandle } from 'react';
import { atom, useAtomValue, Provider, useAtom } from 'jotai';
import Daily from '@daily-co/daily-js';

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return _assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var DailyContext = createContext(null);

/**
 * Returns callObject instance passed to or created by closest <DailyProvider>.
 */
var useDaily = function useDaily() {
  var daily = useContext(DailyContext);
  useDebugValue(daily);
  return daily;
};

var DailyEventContext = createContext({
  on: function on() {},
  off: function off() {}
});

var priorityCounter = -1;
var getPriorityUnique = function getPriorityUnique() {
  return priorityCounter--;
};
var uniqueCounter = 1;
var getUnique = function getUnique() {
  return uniqueCounter++;
};
/**
 * Sets up a daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.
 * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).
 *
 * Warning: callback has to be a memoized reference (e.g. via [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)).
 * Otherwise a console error might be thrown indicating a re-render loop issue.
 *
 * @param ev The DailyEvent to register.
 * @param callback A memoized callback reference to run when the event is emitted.
 */
var useDailyEvent = function useDailyEvent(ev, callback, INTERNAL_priority) {
  if (INTERNAL_priority === void 0) {
    INTERNAL_priority = false;
  }
  var _a = useContext(DailyEventContext),
    off = _a.off,
    on = _a.on;
  var _b = __read(useState(false), 2),
    isBlocked = _b[0],
    setIsBlocked = _b[1];
  var reassignCount = useRef(0);
  var eventId = useMemo(function () {
    return INTERNAL_priority ? getPriorityUnique() : getUnique();
  }, [INTERNAL_priority]);
  useEffect(function () {
    if (!ev || isBlocked) return;
    /**
     * Check if callback has been reassigned often enough without hitting the 50ms timeout.
     */
    if (reassignCount.current > 100000) {
      console.error("useDailyEvent called with potentially non-memoized event callback or due to too many re-renders.\n        Memoize using useCallback to avoid re-render loop or reduce the amount of state transitions the callback depends on.\n        Passed callback for '".concat(ev, "' event is NOT registered."), callback);
      setIsBlocked(true);
      return;
    }
    reassignCount.current++;
    var timeout = setTimeout(function () {
      reassignCount.current = 0;
    }, 50);
    on(ev, callback, eventId);
    return function () {
      clearTimeout(timeout);
      off(ev, eventId);
    };
  }, [callback, ev, eventId, isBlocked, off, on]);
  useDebugValue({
    event: ev,
    eventId: eventId,
    isBlocked: isBlocked,
    callback: callback
  });
};

/**
 * Compares two variables for deep equality.
 * Gracefully handles equality checks on MediaStreamTracks by comparing their ids.
 */
function customDeepEqual(a, b) {
  var e_1, _a;
  if (a === b) return true;
  // Handle arrays separately
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (!customDeepEqual(a[i], b[i])) return false;
    }
    return true;
  }
  // Handle specific cases like MediaStream, MediaStreamTrack, Date, etc.
  if (MediaStream) {
    if (a instanceof MediaStream && b instanceof MediaStream) {
      return a.id === b.id && a.active === b.active && a.getTracks().length === b.getTracks().length && a.getTracks().every(function (track, idx) {
        return customDeepEqual(track, b.getTracks()[idx]);
      });
    }
  }
  // Handle special case for MediaStreamTrack
  if (MediaStreamTrack) {
    if (a instanceof MediaStreamTrack && b instanceof MediaStreamTrack) {
      return a.id === b.id && a.kind === b.kind && a.readyState === b.readyState;
    }
  }
  // Handle special case for Date
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  // Handle special case for RegExp
  if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.flags === b.flags;
  }
  // Handle Set comparisons
  if (a instanceof Set && b instanceof Set) {
    if (a.size !== b.size) return false;
    var arrA = Array.from(a).sort();
    var arrB_1 = Array.from(b).sort();
    return arrA.every(function (val, idx) {
      return customDeepEqual(val, arrB_1[idx]);
    });
  }
  // Handle Map comparisons
  if (a instanceof Map && b instanceof Map) {
    if (a.size !== b.size) return false;
    try {
      for (var _b = __values(a.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2),
          key = _d[0],
          value = _d[1];
        if (!b.has(key) || !customDeepEqual(value, b.get(key))) return false;
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return true;
  }
  // Primitive types and null checks
  if (_typeof(a) !== 'object' || a === null || _typeof(b) !== 'object' || b === null) {
    return false;
  }
  // Generic object handling
  var keysA = Object.keys(a);
  var keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (var i = 0; i < keysA.length; i++) {
    var key = keysA[i];
    if (!Object.prototype.hasOwnProperty.call(b, key) || !customDeepEqual(a[key], b[key])) {
      return false;
    }
  }
  // All keys and values match -> the objects are deeply equal
  return true;
}
/**
 * Comparison function optimized for comparing arrays.
 */
function arraysDeepEqual(a, b) {
  // Check for reference equality
  if (a === b) return true;
  // Check if both arrays are of the same length
  if (a.length !== b.length) return false;
  // Compare each element in the array
  for (var i = 0; i < a.length; i++) {
    var valueA = a[i];
    var valueB = b[i];
    var isComplexTypeA = valueA !== null && _typeof(valueA) === 'object';
    var isComplexTypeB = valueB !== null && _typeof(valueB) === 'object';
    // Use customDeepEqual only if either value is a complex type
    if (isComplexTypeA || isComplexTypeB) {
      if (!customDeepEqual(valueA, valueB)) return false;
    } else if (valueA !== valueB) {
      return false;
    }
  }
  return true;
}

function jotaiDebugLabel(label) {
  return 'daily-react-' + label;
}
function equalAtomFamily(options) {
  var atomCache = new Map();
  var priorValues = new Map();
  return function (param) {
    if (!atomCache.has(param)) {
      var baseAtom = atom(function (get) {
        var derivedValue = options.get(param)(get);
        var prior = priorValues.get(param);
        if (prior != null && options.equals(derivedValue, prior)) {
          return prior;
        }
        priorValues.set(param, derivedValue);
        return derivedValue;
      });
      atomCache.set(param, baseAtom);
    }
    return atomCache.get(param);
  };
}

var DELIM = '::';
var PATHS_DELIM = ';';
var getPropertyParam = function getPropertyParam(id, property) {
  return id + DELIM + property;
};
var getPropertiesParam = function getPropertiesParam(id, properties) {
  return id + DELIM + properties.join(PATHS_DELIM);
};
var getParticipantPropertyAtom = function getParticipantPropertyAtom(id, property) {
  return participantPropertyState(getPropertyParam(id, property));
};
/**
 * Stores all property paths for a given participant.
 */
var participantPropertyPathsState = atomFamily(function (id) {
  var participantPropertyPathsAtom = atom([]);
  participantPropertyPathsAtom.debugLabel = jotaiDebugLabel("participant-property-paths-".concat(id));
  return participantPropertyPathsAtom;
});
/**
 * Stores resolved values for each participant and property path.
 */
var participantPropertyState = atomFamily(function (param) {
  var participantPropertyAtom = atom(null);
  participantPropertyAtom.debugLabel = jotaiDebugLabel("participant-property-".concat(param));
  return participantPropertyAtom;
});
/**
 * Stores resolved values for each participant and property path.
 */
var participantPropertiesState = equalAtomFamily({
  equals: arraysDeepEqual,
  get: function get(param) {
    return function (get) {
      var _a = __read(param.split(DELIM), 2),
        id = _a[0],
        paths = _a[1];
      var properties = paths.split(PATHS_DELIM);
      return properties.map(function (path) {
        return get(getParticipantPropertyAtom(id, path));
      });
    };
  }
});
/**
 * Returns a participant's property that you subscribe to.
 * @param participantId The participant's session_id.
 * @param propertyPaths the array of participant property that you want to subscribe to.
 */
var useParticipantProperty = function useParticipantProperty(participantId, propertyPaths) {
  var _a;
  var properties = useAtomValue(Array.isArray(propertyPaths) ? participantPropertiesState(getPropertiesParam(participantId, propertyPaths)) : participantPropertyState(getPropertyParam(participantId, propertyPaths)));
  useDebugValue(Array.isArray(propertyPaths) ? propertyPaths.reduce(function (o, path, i) {
    o[path] = properties[i];
    return o;
  }, {}) : (_a = {}, _a[propertyPaths] = properties, _a));
  return properties;
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var lodash_throttle;
var hasRequiredLodash_throttle;
function requireLodash_throttle() {
  if (hasRequiredLodash_throttle) return lodash_throttle;
  hasRequiredLodash_throttle = 1;
  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
    nativeMin = Math.min;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function now() {
    return root.Date.now();
  };

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs,
        thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }
    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(),
        isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
      trailing = true;
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = _typeof(value);
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && _typeof(value) == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_throttle = throttle;
  return lodash_throttle;
}

var lodash_throttleExports = requireLodash_throttle();
var throttle = /*@__PURE__*/getDefaultExportFromCjs(lodash_throttleExports);

/**
 * Sets up a throttled daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.
 * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).
 *
 * In comparison to useDailyEvent the callback passed here will be called with an array of event objects.
 *
 * You can pass an array of DailyEvents to register multiple daily events with a single callback handler.
 * The events returned in the callback parameter are guaranteed to be in the same order as they were emitted.
 *
 * @param ev The DailyEvent to register or an array of DailyEvent to register.
 * @param callback A memoized callback reference to run when throttled events are emitted.
 * @param throttleTimeout The minimum waiting time until the callback is called again. Default: 500
 */
var useThrottledDailyEvent = function useThrottledDailyEvent(ev, callback, throttleTimeout, INTERNAL_priority) {
  if (throttleTimeout === void 0) {
    throttleTimeout = 500;
  }
  if (INTERNAL_priority === void 0) {
    INTERNAL_priority = false;
  }
  var _a = useContext(DailyEventContext),
    off = _a.off,
    on = _a.on;
  var eventId = useMemo(function () {
    var _a;
    if (Array.isArray(ev)) return ev.reduce(function (r, e) {
      r[e] = INTERNAL_priority ? getPriorityUnique() : getUnique();
      return r;
    }, {});
    return _a = {}, _a[ev] = INTERNAL_priority ? getPriorityUnique() : getUnique(), _a;
  }, [ev, INTERNAL_priority]);
  var throttledEvents = useRef([]);
  useDailyEvent('call-instance-destroyed', useCallback(function () {
    throttledEvents.current.length = 0;
  }, []));
  var emitEvents = useMemo(function () {
    return throttle(function () {
      if (throttledEvents.current.length === 0) return;
      callback(throttledEvents.current);
      throttledEvents.current.length = 0;
    }, throttleTimeout, {
      trailing: true
    });
  }, [callback, throttleTimeout]);
  useEffect(function () {
    if (!ev) return;
    var addEvent = function addEvent(ev) {
      throttledEvents.current.push(ev);
      emitEvents();
    };
    if (Array.isArray(ev)) {
      ev.forEach(function (e) {
        return on(e, addEvent, eventId[e]);
      });
    } else {
      on(ev, addEvent, eventId[ev]);
    }
    return function () {
      if (Array.isArray(ev)) {
        ev.forEach(function (e) {
          return off(e, eventId[e]);
        });
      } else {
        off(ev, eventId[ev]);
      }
    };
  }, [emitEvents, ev, eventId, off, on]);
  useDebugValue({
    event: ev,
    eventId: eventId
  });
};

/**
 * Returns all property paths for an object.
 */
var _getPaths = function getPaths(o, currentPath, visited) {
  if (currentPath === void 0) {
    currentPath = '';
  }
  if (visited === void 0) {
    visited = new Set();
  }
  if (_typeof(o) !== 'object' || o === null || visited.has(o)) {
    return [currentPath];
  }
  visited.add(o);
  var paths = [];
  for (var key in o) {
    if (Object.prototype.hasOwnProperty.call(o, key)) {
      var newPath = currentPath ? "".concat(currentPath, ".").concat(key) : key;
      paths.push.apply(paths, __spreadArray([newPath], __read(_getPaths(o[key], newPath, visited)), false));
    }
  }
  visited["delete"](o);
  return paths;
};
/**
 * Returns all property paths for a given participant object.
 */
var getParticipantPaths = function getParticipantPaths(p) {
  return _getPaths(p);
};

var resolvePath = function resolvePath(participant, path) {
  return String(path).split('.').filter(function (key) {
    return key.length;
  }).reduce(function (p, key) {
    return p && p[key];
  }, participant);
};
var resolveParticipantPaths = function resolveParticipantPaths(participant, paths) {
  return paths.map(function (path) {
    return resolvePath(participant, path);
  });
};

/**
 * Stores the most recent peerId as reported from [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.
 */
var activeIdState = atom(null);
activeIdState.debugLabel = jotaiDebugLabel('active-id');
var localIdState = atom('');
localIdState.debugLabel = jotaiDebugLabel('local-id');
var localJoinDateState = atom(null);
localJoinDateState.debugLabel = jotaiDebugLabel('local-join-date');
var participantIdsState = atom([]);
participantIdsState.debugLabel = jotaiDebugLabel('participant-ids');
var participantState = atomFamily(function (id) {
  var participantAtom = atom(null);
  participantAtom.debugLabel = jotaiDebugLabel("participant-".concat(id));
  return participantAtom;
});
var waitingParticipantsState = atom([]);
waitingParticipantsState.debugLabel = jotaiDebugLabel('waiting-participants');
var waitingParticipantState = atomFamily(function (id) {
  var waitingParticipantAtom = atom({
    awaitingAccess: {
      level: 'full'
    },
    id: id,
    name: ''
  });
  waitingParticipantAtom.debugLabel = jotaiDebugLabel("waiting-participant-".concat(id));
  return waitingParticipantAtom;
});
var allWaitingParticipantsSelector = equalAtomFamily({
  equals: arraysDeepEqual,
  get: function get() {
    return function (get) {
      var ids = get(waitingParticipantsState);
      return ids.map(function (id) {
        return get(waitingParticipantState(id));
      });
    };
  }
});
var DailyParticipants = function DailyParticipants(_a) {
  var children = _a.children;
  var daily = useDaily();
  var _b = __read(useState(false), 2),
    initialized = _b[0],
    setInitialized = _b[1];
  var initParticipants = useAtomCallback(useCallback(function (_get, set, participants) {
    set(localIdState, participants.local.session_id);
    var participantsArray = Object.values(participants);
    var ids = participantsArray.map(function (p) {
      return p.session_id;
    });
    set(participantIdsState, ids);
    participantsArray.forEach(function (p) {
      set(participantState(p.session_id), p);
      var paths = getParticipantPaths(p);
      set(participantPropertyPathsState(p.session_id), paths);
      paths.forEach(function (property) {
        var _a = __read(resolveParticipantPaths(p, [property]), 1),
          value = _a[0];
        set(getParticipantPropertyAtom(p.session_id, property), value);
      });
    });
    setInitialized(true);
  }, []));
  /**
   * Initialize participants state based on daily.participants().
   * Retries every 100ms to initialize the state, until daily is ready.
   */
  useEffect(function () {
    if (!daily || initialized) return;
    var interval = setInterval(function () {
      var participants = daily.participants();
      if (!('local' in participants)) return;
      initParticipants(participants);
      clearInterval(interval);
    }, 100);
    return function () {
      clearInterval(interval);
    };
  }, [daily, initialized, initParticipants]);
  var handleInitEvent = useCallback(function () {
    if (!daily) return;
    var participants = daily === null || daily === void 0 ? void 0 : daily.participants();
    if (!participants.local) return;
    initParticipants(participants);
  }, [daily, initParticipants]);
  useDailyEvent('started-camera', handleInitEvent, true);
  useDailyEvent('access-state-updated', handleInitEvent, true);
  useDailyEvent('joining-meeting', useAtomCallback(useCallback(function (_get, set) {
    set(localJoinDateState, new Date());
    handleInitEvent();
  }, [handleInitEvent])), true);
  useDailyEvent('joined-meeting', useCallback(function (ev) {
    initParticipants(ev.participants);
  }, [initParticipants]), true);
  /**
   * Reset stored participants, when meeting has ended.
   */
  var handleCleanup = useAtomCallback(useCallback(function (get, set) {
    set(localIdState, '');
    set(activeIdState, null);
    var ids = get(participantIdsState);
    ids.forEach(function (id) {
      return participantState.remove(id);
    });
    set(participantIdsState, []);
  }, []));
  useDailyEvent('call-instance-destroyed', handleCleanup, true);
  useDailyEvent('left-meeting', handleCleanup, true);
  useThrottledDailyEvent(['active-speaker-change', 'participant-joined', 'participant-updated', 'participant-left'], useAtomCallback(useCallback(function (get, set, evts) {
    if (!evts.length) return;
    evts.forEach(function (ev) {
      switch (ev.action) {
        case 'active-speaker-change':
          {
            set(activeIdState, ev.activeSpeaker.peerId);
            set(participantState(ev.activeSpeaker.peerId), function (prev) {
              if (!prev) return null;
              return _assign(_assign({}, prev), {
                last_active: new Date()
              });
            });
            break;
          }
        case 'participant-joined':
          {
            // Update list of ids
            set(participantIdsState, function (prevIds) {
              return prevIds.includes(ev.participant.session_id) ? prevIds : __spreadArray(__spreadArray([], __read(prevIds), false), [ev.participant.session_id], false);
            });
            // Store entire object
            set(participantState(ev.participant.session_id), ev.participant);
            var paths = getParticipantPaths(ev.participant);
            // Set list of property paths
            set(participantPropertyPathsState(ev.participant.session_id), paths);
            // Set all property path values
            paths.forEach(function (property) {
              var _a = __read(resolveParticipantPaths(ev.participant, [property]), 1),
                value = _a[0];
              set(getParticipantPropertyAtom(ev.participant.session_id, property), value);
            });
            break;
          }
        case 'participant-updated':
          {
            // Update entire object
            set(participantState(ev.participant.session_id), ev.participant);
            // Update local session_id
            if (ev.participant.local) {
              set(localIdState, ev.participant.session_id);
            }
            var paths = getParticipantPaths(ev.participant);
            var oldPaths_1 = get(participantPropertyPathsState(ev.participant.session_id));
            var pathsChanged = paths.length !== oldPaths_1.length || paths.some(function (path) {
              return !oldPaths_1.includes(path);
            });
            // Set list of property paths
            if (pathsChanged) {
              set(participantPropertyPathsState(ev.participant.session_id), paths);
            }
            // Create a Set of oldPaths for quick lookup
            var oldPathSet_1 = new Set(oldPaths_1);
            // Resolve all path values in one call
            var resolvedValues_1 = resolveParticipantPaths(ev.participant, paths);
            paths.forEach(function (property, idx) {
              var value = resolvedValues_1[idx];
              // Remove property from oldPathSet to mark it as processed
              oldPathSet_1["delete"](property);
              // Only update if the new value differs from the current one
              set(getParticipantPropertyAtom(ev.participant.session_id, property), function (prev) {
                return customDeepEqual(prev, value) ? prev : value;
              });
            });
            // Set any remaining paths in oldPathSet to null
            oldPathSet_1.forEach(function (property) {
              set(getParticipantPropertyAtom(ev.participant.session_id, property), null);
            });
            break;
          }
        case 'participant-left':
          {
            // Remove from list of ids
            set(participantIdsState, function (prevIds) {
              return prevIds.includes(ev.participant.session_id) ? prevIds.filter(function (id) {
                return id !== ev.participant.session_id;
              }) : prevIds;
            });
            // Remove entire object
            participantState.remove(ev.participant.session_id);
            var oldPaths = get(participantPropertyPathsState(ev.participant.session_id));
            // Remove property path values
            oldPaths.forEach(function (property) {
              participantPropertyState.remove(getPropertyParam(ev.participant.session_id, property));
            });
            // Remove all property paths
            participantPropertyPathsState.remove(ev.participant.session_id);
            break;
          }
      }
    });
  }, [])), 100, true);
  useThrottledDailyEvent(['waiting-participant-added', 'waiting-participant-updated', 'waiting-participant-removed'], useAtomCallback(useCallback(function (_get, set, evts) {
    evts.forEach(function (ev) {
      switch (ev.action) {
        case 'waiting-participant-added':
          set(waitingParticipantsState, function (wps) {
            return wps.includes(ev.participant.id) ? wps : __spreadArray(__spreadArray([], __read(wps), false), [ev.participant.id], false);
          });
          set(waitingParticipantState(ev.participant.id), ev.participant);
          break;
        case 'waiting-participant-updated':
          set(waitingParticipantState(ev.participant.id), ev.participant);
          break;
        case 'waiting-participant-removed':
          set(waitingParticipantsState, function (wps) {
            return wps.filter(function (wp) {
              return wp !== ev.participant.id;
            });
          });
          waitingParticipantState.remove(ev.participant.id);
          break;
      }
    });
  }, [])), 100, true);
  return React.createElement(React.Fragment, null, children);
};

/**
 * Returns the local participant's session_id or empty string '',
 * if the local participant doesn't exist.
 */
var useLocalSessionId = function useLocalSessionId() {
  var localId = useAtomValue(localIdState);
  useDebugValue(localId);
  return localId;
};

var noopFilter = function noopFilter() {
  return true;
};
/**
 * Returns the most recent speaker id mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.
 */
var useActiveSpeakerId = function useActiveSpeakerId(_a) {
  var _b = _a === void 0 ? {} : _a,
    _c = _b.filter,
    filter = _c === void 0 ? noopFilter : _c,
    _d = _b.ignoreLocal,
    ignoreLocal = _d === void 0 ? false : _d;
  var localSessionId = useLocalSessionId();
  var recentActiveId = useAtomValue(activeIdState);
  var isIgnoredLocalId = ignoreLocal && recentActiveId === localSessionId;
  var isFilteredOut = !(filter === null || filter === void 0 ? void 0 : filter(recentActiveId));
  var isRecentIdRelevant = !isIgnoredLocalId && !isFilteredOut;
  var _e = __read(useState(isRecentIdRelevant ? recentActiveId : null), 2),
    activeId = _e[0],
    setActiveId = _e[1];
  useEffect(function () {
    if (isIgnoredLocalId || isFilteredOut) return;
    setActiveId(recentActiveId);
  }, [isFilteredOut, isIgnoredLocalId, recentActiveId]);
  useDebugValue(activeId);
  return activeId;
};

var isTrackOff = function isTrackOff(trackState) {
  return ['blocked', 'off'].includes(trackState);
};

var SERIALIZABLE_DELIM = ';';
var getParticipantIdsFilterSortParam = function getParticipantIdsFilterSortParam(filter, sort) {
  return "".concat(filter).concat(SERIALIZABLE_DELIM).concat(sort);
};
/**
 * Short-cut state selector for useParticipantIds({ filter: 'local' })
 */
var participantIdsFilteredAndSortedState = equalAtomFamily({
  equals: customDeepEqual,
  get: function get(param) {
    return function (get) {
      var _a = __read(param.split(SERIALIZABLE_DELIM), 2),
        filter = _a[0],
        sort = _a[1];
      var ids = get(participantIdsState);
      return ids.filter(function (id) {
        switch (filter) {
          /**
           * Simple boolean fields first.
           */
          case 'local':
          case 'owner':
          case 'record':
            {
              return get(getParticipantPropertyAtom(id, filter));
            }
          case 'remote':
            {
              return !get(getParticipantPropertyAtom(id, 'local'));
            }
          case 'screen':
            {
              var screenAudioState = get(getParticipantPropertyAtom(id, 'tracks.screenAudio.state'));
              var screenVideoState = get(getParticipantPropertyAtom(id, 'tracks.screenVideo.state'));
              return !isTrackOff(screenAudioState) || !isTrackOff(screenVideoState);
            }
          default:
            return true;
        }
      }).sort(function (idA, idB) {
        switch (sort) {
          case 'joined_at':
          case 'session_id':
          case 'user_id':
          case 'user_name':
            {
              var aSort = get(getParticipantPropertyAtom(idA, sort));
              var bSort = get(getParticipantPropertyAtom(idB, sort));
              if (aSort !== undefined || bSort !== undefined) {
                if (aSort === undefined) return -1;
                if (bSort === undefined) return 1;
                if (aSort > bSort) return 1;
                if (aSort < bSort) return -1;
              }
              return 0;
            }
          default:
            return 0;
        }
      });
    };
  }
});
/**
 * Returns a list of participant ids (= session_id).
 * The list can optionally be filtered and sorted, using the filter and sort options.
 */
var useParticipantIds = function useParticipantIds(_a) {
  var _b = _a === void 0 ? {} : _a,
    filter = _b.filter,
    onActiveSpeakerChange = _b.onActiveSpeakerChange,
    onParticipantJoined = _b.onParticipantJoined,
    onParticipantLeft = _b.onParticipantLeft,
    onParticipantUpdated = _b.onParticipantUpdated,
    sort = _b.sort;
  /**
   * For instances of useParticipantIds with string-based filter and sort,
   * we can immediately return the correct ids from Jotai's state.
   */
  var preFilteredSortedIds = useAtomValue(participantIdsFilteredAndSortedState(getParticipantIdsFilterSortParam(typeof filter === 'string' ? filter : null, typeof sort === 'string' ? sort : null)));
  var shouldUseCustomIds = typeof filter === 'function' || typeof sort === 'function';
  var getCustomFilteredIds = useCallback(function (get) {
    if (
    // Ignore if both filter and sort are not functions.
    typeof filter !== 'function' && typeof sort !== 'function') return [];
    var participants = preFilteredSortedIds.map(function (id) {
      return get(participantState(id));
    });
    return participants
    // Make sure we don't accidentally try to filter/sort `null` participants
    // This can happen when a participant's id is already present in store
    // but the participant object is not stored, yet.
    .filter(function (p) {
      return Boolean(p);
    })
    // Run custom filter, if it's a function. Otherwise don't filter any participants.
    .filter(typeof filter === 'function' ? filter : function () {
      return true;
    })
    // Run custom sort, if it's a function. Otherwise don't sort.
    .sort(typeof sort === 'function' ? sort : function () {
      return 0;
    })
    // Map back to session_id.
    .map(function (p) {
      return p.session_id;
    })
    // Filter any potential null/undefined ids.
    // This shouldn't really happen, but better safe than sorry.
    .filter(Boolean);
  }, [filter, preFilteredSortedIds, sort]);
  var _c = __read(useState([]), 2),
    customIds = _c[0],
    setCustomIds = _c[1];
  var maybeUpdateCustomIds = useAtomCallback(useCallback(function (get) {
    if (!shouldUseCustomIds) return;
    var newIds = getCustomFilteredIds(get);
    if (customDeepEqual(newIds, customIds)) return;
    setCustomIds(newIds);
  }, [customIds, getCustomFilteredIds, shouldUseCustomIds]));
  useEffect(function () {
    maybeUpdateCustomIds();
  }, [maybeUpdateCustomIds]);
  useThrottledDailyEvent(['participant-joined', 'participant-updated', 'active-speaker-change', 'participant-left'], useCallback(function (evts) {
    if (!evts.length) return;
    evts.forEach(function (ev) {
      switch (ev.action) {
        case 'participant-joined':
          onParticipantJoined === null || onParticipantJoined === void 0 ? void 0 : onParticipantJoined(ev);
          break;
        case 'participant-updated':
          onParticipantUpdated === null || onParticipantUpdated === void 0 ? void 0 : onParticipantUpdated(ev);
          break;
        case 'active-speaker-change':
          onActiveSpeakerChange === null || onActiveSpeakerChange === void 0 ? void 0 : onActiveSpeakerChange(ev);
          break;
        case 'participant-left':
          onParticipantLeft === null || onParticipantLeft === void 0 ? void 0 : onParticipantLeft(ev);
          break;
      }
    });
    maybeUpdateCustomIds();
  }, [maybeUpdateCustomIds, onActiveSpeakerChange, onParticipantJoined, onParticipantLeft, onParticipantUpdated]));
  var result = typeof filter === 'function' || typeof sort === 'function' ? customIds : preFilteredSortedIds;
  useDebugValue(result);
  return result;
};

var screenSharesState = equalAtomFamily({
  equals: arraysDeepEqual,
  get: function get() {
    return function (get) {
      var screenIds = get(participantIdsFilteredAndSortedState(getParticipantIdsFilterSortParam('screen', null)));
      return screenIds.map(function (id) {
        return {
          local: get(getParticipantPropertyAtom(id, 'local')),
          screenAudio: get(getParticipantPropertyAtom(id, 'tracks.screenAudio')),
          screenVideo: get(getParticipantPropertyAtom(id, 'tracks.screenVideo')),
          screenId: "".concat(id, "-screen"),
          session_id: id
        };
      });
    };
  }
});
/**
 * Allows access to information about shared screens, and methods to start or stop a local screen share.
 */
var useScreenShare = function useScreenShare(_a) {
  var _b = _a === void 0 ? {} : _a,
    onError = _b.onError,
    onLocalScreenShareStarted = _b.onLocalScreenShareStarted,
    onLocalScreenShareStopped = _b.onLocalScreenShareStopped;
  var daily = useDaily();
  var startScreenShare = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    daily === null || daily === void 0 ? void 0 : daily.startScreenShare.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var stopScreenShare = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    daily === null || daily === void 0 ? void 0 : daily.stopScreenShare.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  useDailyEvent('local-screen-share-started', useCallback(function () {
    return onLocalScreenShareStarted === null || onLocalScreenShareStarted === void 0 ? void 0 : onLocalScreenShareStarted();
  }, [onLocalScreenShareStarted]));
  useDailyEvent('local-screen-share-stopped', useCallback(function () {
    return onLocalScreenShareStopped === null || onLocalScreenShareStopped === void 0 ? void 0 : onLocalScreenShareStopped();
  }, [onLocalScreenShareStopped]));
  useDailyEvent('nonfatal-error', useCallback(function (ev) {
    if (ev.type !== 'screen-share-error') return;
    onError === null || onError === void 0 ? void 0 : onError(ev);
  }, [onError]));
  var screens = useAtomValue(screenSharesState(undefined));
  var result = {
    isSharingScreen: screens.some(function (s) {
      return s.local;
    }),
    screens: screens,
    startScreenShare: startScreenShare,
    stopScreenShare: stopScreenShare
  };
  useDebugValue(result);
  return result;
};

/**
 * Returns a participant's track and state, based on the given MediaType.
 *
 * Equivalent to daily.participants()[participantId].tracks[type].
 *
 * @param participantId The participant's session_id.
 * @param type The track type. Default: "video"
 */
var useMediaTrack = function useMediaTrack(participantId, type) {
  if (type === void 0) {
    type = 'video';
  }
  var trackState = useParticipantProperty(participantId, "tracks.".concat(type));
  var result = trackState ? _assign(_assign({}, trackState), {
    isOff: isTrackOff(trackState.state)
  }) : {
    isOff: true,
    persistentTrack: undefined,
    state: 'off',
    subscribed: false
  };
  useDebugValue(result);
  return result;
};

function useMergedRef() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  return useCallback(function (element) {
    for (var i = 0; i < refs.length; i++) {
      var ref = refs[i];
      if (typeof ref === 'function') ref(element);else if (ref && _typeof(ref) === 'object') ref.current = element;
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  refs);
}

var DailyAudioTrack = memo(forwardRef(function (_a, ref) {
  var onPlayFailed = _a.onPlayFailed,
    sessionId = _a.sessionId,
    _b = _a.type,
    type = _b === void 0 ? 'audio' : _b,
    props = __rest(_a, ["onPlayFailed", "sessionId", "type"]);
  var audioEl = useRef(null);
  var audio = useMediaTrack(sessionId, type);
  var audioRef = useMergedRef(audioEl, ref);
  var subscribedState = audio === null || audio === void 0 ? void 0 : audio.subscribed;
  /**
   * Setup audio tag.
   */
  useEffect(function () {
    var audioTag = audioEl.current;
    if (!audioTag || !(audio === null || audio === void 0 ? void 0 : audio.persistentTrack)) return;
    var handleCanPlay = function handleCanPlay() {
      audioTag.play()["catch"](function (e) {
        onPlayFailed === null || onPlayFailed === void 0 ? void 0 : onPlayFailed({
          sessionId: sessionId,
          target: audioTag,
          type: type,
          message: e.message,
          name: e.name
        });
      });
    };
    if (!MediaStream) {
      console.warn("MediaStream API not available. Can't setup ".concat(type, " for ").concat(sessionId));
      onPlayFailed === null || onPlayFailed === void 0 ? void 0 : onPlayFailed({
        sessionId: sessionId,
        target: audioTag,
        type: type,
        message: 'MediaStream API not available',
        name: 'MediaStream API not available'
      });
      return;
    }
    audioTag.addEventListener('canplay', handleCanPlay);
    audioTag.srcObject = new MediaStream([audio === null || audio === void 0 ? void 0 : audio.persistentTrack]);
    return function () {
      audioTag === null || audioTag === void 0 ? void 0 : audioTag.removeEventListener('canplay', handleCanPlay);
    };
  }, [audio === null || audio === void 0 ? void 0 : audio.persistentTrack, onPlayFailed, sessionId, type]);
  useDailyEvent('participant-left', useCallback(function (ev) {
    var audioTag = audioEl.current;
    if (ev.participant.session_id !== sessionId || !audioTag) return;
    audioTag.srcObject = null;
  }, [sessionId]));
  return React.createElement("audio", _assign({
    autoPlay: true,
    ref: audioRef
  }, props, {
    "data-session-id": sessionId,
    "data-audio-type": type,
    "data-subscribed": subscribedState
  }));
}));
DailyAudioTrack.displayName = 'DailyAudioTrack';

var DailyAudio = memo(forwardRef(function (_a, ref) {
  var _b = _a.autoSubscribeActiveSpeaker,
    autoSubscribeActiveSpeaker = _b === void 0 ? false : _b,
    _c = _a.maxSpeakers,
    maxSpeakers = _c === void 0 ? 5 : _c,
    onPlayFailed = _a.onPlayFailed,
    _d = _a.playLocalScreenAudio,
    playLocalScreenAudio = _d === void 0 ? false : _d;
  var daily = useDaily();
  var _e = __read(useState(new Array(maxSpeakers).fill('')), 2),
    speakers = _e[0],
    setSpeakers = _e[1];
  var screens = useScreenShare().screens;
  var localSessionId = useLocalSessionId();
  var activeSpeakerId = useActiveSpeakerId({
    ignoreLocal: true
  });
  var containerRef = useRef(null);
  useImperativeHandle(ref, function () {
    return {
      getActiveSpeakerAudio: function getActiveSpeakerAudio() {
        var _a, _b;
        return (_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector("audio[data-session-id=\"".concat(activeSpeakerId, "\"][data-audio-type=\"audio\"]"))) !== null && _b !== void 0 ? _b : null;
      },
      getAllAudio: function getAllAudio() {
        var _a, _b;
        return Array.from((_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('audio')) !== null && _b !== void 0 ? _b : []);
      },
      getAudioBySessionId: function getAudioBySessionId(id) {
        var _a, _b;
        return (_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector("audio[data-session-id=\"".concat(id, "\"][data-audio-type=\"audio\"]"))) !== null && _b !== void 0 ? _b : null;
      },
      getRmpAudio: function getRmpAudio() {
        var _a, _b;
        return Array.from((_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('audio[data-audio-type="rmpAudio"]')) !== null && _b !== void 0 ? _b : []);
      },
      getScreenAudio: function getScreenAudio() {
        var _a, _b;
        return Array.from((_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('audio[data-audio-type="screenAudio"]')) !== null && _b !== void 0 ? _b : []);
      },
      getRmpAudioBySessionId: function getRmpAudioBySessionId(id) {
        var _a, _b;
        return (_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector("audio[data-session-id=\"".concat(id, "\"][data-audio-type=\"rmpAudio\"]"))) !== null && _b !== void 0 ? _b : null;
      },
      getScreenAudioBySessionId: function getScreenAudioBySessionId(id) {
        var _a, _b;
        return (_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector("audio[data-session-id=\"".concat(id, "\"][data-audio-type=\"screenAudio\"]"))) !== null && _b !== void 0 ? _b : null;
      }
    };
  }, [activeSpeakerId]);
  var assignSpeaker = useAtomCallback(useCallback(function (get, _set, sessionId) {
    return __awaiter(void 0, void 0, void 0, function () {
      var subscribedParticipants, isSubscribed;
      var _a;
      return __generator(this, function (_b) {
        subscribedParticipants = Object.values((_a = daily === null || daily === void 0 ? void 0 : daily.participants()) !== null && _a !== void 0 ? _a : {}).filter(function (p) {
          return !p.local && Boolean(p.tracks.audio.subscribed);
        });
        isSubscribed = function isSubscribed(id) {
          return subscribedParticipants.some(function (p) {
            return p.session_id === id;
          });
        };
        if (!isSubscribed(sessionId)) {
          if (daily && !daily.isDestroyed() && autoSubscribeActiveSpeaker && !daily.subscribeToTracksAutomatically()) {
            daily.updateParticipant(sessionId, {
              setSubscribedTracks: {
                audio: true
              }
            });
          } else {
            return [2 /*return*/];
          }
        }

        setSpeakers(function (prevSpeakers) {
          var _a;
          // New speaker is already present
          if (prevSpeakers.includes(sessionId)) return prevSpeakers;
          // Try to find a free slot: either unassigned or unsubscribed
          var freeSlotCheck = function freeSlotCheck(id) {
            return !id || !isSubscribed(id);
          };
          if (prevSpeakers.some(freeSlotCheck)) {
            var idx = prevSpeakers.findIndex(freeSlotCheck);
            prevSpeakers[idx] = sessionId;
            return __spreadArray([], __read(prevSpeakers), false);
          }
          // From here on we can assume that all assigned audio tracks are subscribed.
          // Try to find muted recent speaker
          var mutedIdx = prevSpeakers.findIndex(function (id) {
            return subscribedParticipants.some(function (p) {
              return p.session_id === id && isTrackOff(p.tracks.audio.state);
            });
          });
          if (mutedIdx >= 0) {
            prevSpeakers[mutedIdx] = sessionId;
            return __spreadArray([], __read(prevSpeakers), false);
          }
          // Find least recent non-active speaker and replace with new speaker
          var speakerObjects = subscribedParticipants.filter(function (p) {
            // Only consider participants currently assigned to speaker slots
            return prevSpeakers.includes(p.session_id) &&
            // Don't replace current active participant, to avoid audio drop-outs
            p.session_id !== activeSpeakerId;
          }).sort(function (a, b) {
            var _a, _b;
            var lastActiveA = (_a = get(getParticipantPropertyAtom(a.session_id, 'last_active'))) !== null && _a !== void 0 ? _a : new Date('1970-01-01');
            var lastActiveB = (_b = get(getParticipantPropertyAtom(b.session_id, 'last_active'))) !== null && _b !== void 0 ? _b : new Date('1970-01-01');
            if (lastActiveA > lastActiveB) return 1;
            if (lastActiveA < lastActiveB) return -1;
            return 0;
          });
          // No previous speaker in call anymore. Assign first free slot.
          if (!speakerObjects.length) {
            // Don't replace the active speaker. Instead find first non-active speaker slot.
            var replaceIdx_1 = prevSpeakers.findIndex(function (id) {
              return id !== activeSpeakerId;
            });
            prevSpeakers[replaceIdx_1] = sessionId;
            return __spreadArray([], __read(prevSpeakers), false);
          }
          // Replace least recent speaker with new speaker
          var replaceIdx = prevSpeakers.indexOf((_a = speakerObjects[0]) === null || _a === void 0 ? void 0 : _a.session_id);
          prevSpeakers[replaceIdx] = sessionId;
          return __spreadArray([], __read(prevSpeakers), false);
        });
        return [2 /*return*/];
      });
    });
  }, [activeSpeakerId, autoSubscribeActiveSpeaker, daily]));
  /**
   * Unassigns speaker from speaker slot, e.g. because participant left the call.
   */
  var removeSpeaker = useCallback(function (sessionId) {
    setSpeakers(function (prevSpeakers) {
      if (!prevSpeakers.includes(sessionId)) return prevSpeakers;
      var newSpeakers = __spreadArray([], __read(prevSpeakers), false);
      var idx = newSpeakers.indexOf(sessionId);
      newSpeakers[idx] = '';
      return newSpeakers;
    });
  }, []);
  useThrottledDailyEvent(['active-speaker-change', 'track-started', 'participant-left'], useCallback(function (evts) {
    evts.forEach(function (ev) {
      switch (ev.action) {
        case 'active-speaker-change':
          if (ev.activeSpeaker.peerId === localSessionId) return;
          assignSpeaker(ev.activeSpeaker.peerId);
          break;
        case 'track-started':
          if (ev.track.kind === 'audio' && ev.participant && !ev.participant.local) {
            assignSpeaker(ev.participant.session_id);
          }
          break;
        case 'participant-left':
          removeSpeaker(ev.participant.session_id);
          break;
      }
    });
  }, [assignSpeaker, localSessionId, removeSpeaker]), 200);
  var rmpAudioIds = useParticipantIds({
    filter: useCallback(function (p) {
      var _a;
      return Boolean((_a = p === null || p === void 0 ? void 0 : p.tracks) === null || _a === void 0 ? void 0 : _a.rmpAudio);
    }, [])
  });
  return React.createElement("div", {
    ref: containerRef
  }, speakers.map(function (sessionId, idx) {
    return React.createElement(DailyAudioTrack, {
      key: "speaker-slot-".concat(idx),
      onPlayFailed: onPlayFailed,
      sessionId: sessionId,
      type: "audio"
    });
  }), screens.filter(function (screen) {
    return playLocalScreenAudio ? true : !screen.local;
  }).map(function (screen) {
    return React.createElement(DailyAudioTrack, {
      key: screen.screenId,
      onPlayFailed: onPlayFailed,
      sessionId: screen.session_id,
      type: "screenAudio"
    });
  }), rmpAudioIds.map(function (id) {
    return React.createElement(DailyAudioTrack, {
      key: "".concat(id, "-rmp"),
      onPlayFailed: onPlayFailed,
      sessionId: id,
      type: "rmpAudio"
    });
  }));
}));
DailyAudio.displayName = 'DailyAudio';

var DailyVideo = forwardRef(function DailyVideo(_a, ref) {
  var automirror = _a.automirror,
    _b = _a.fit,
    fit = _b === void 0 ? 'contain' : _b,
    mirror = _a.mirror,
    onResize = _a.onResize,
    _c = _a.playableStyle,
    playableStyle = _c === void 0 ? {} : _c,
    sessionId = _a.sessionId,
    _d = _a.style,
    style = _d === void 0 ? {} : _d,
    _e = _a.type,
    type = _e === void 0 ? 'video' : _e,
    props = __rest(_a, ["automirror", "fit", "mirror", "onResize", "playableStyle", "sessionId", "style", "type"]);
  var localSessionId = useLocalSessionId();
  var isLocal = localSessionId === sessionId;
  var isScreen = type === 'screenVideo';
  var isLocalCam = isLocal && !isScreen;
  var videoEl = useRef(null);
  var videoRef = useMergedRef(videoEl, ref);
  var videoState = useMediaTrack(sessionId, type);
  var videoTrack = videoState.persistentTrack;
  /**
   * Considered as playable video:
   * - local cam feed
   * - any screen share
   * - remote cam feed that is subscribed and reported as playable
   */
  var isPlayable = isLocalCam || isScreen || !videoState.isOff;
  var trackState = useParticipantProperty(sessionId, "tracks.".concat(type));
  var subscribedState = trackState === null || trackState === void 0 ? void 0 : trackState.subscribed;
  /**
   * Determine if video needs to be mirrored.
   */
  var isMirrored = useMemo(function () {
    if (typeof mirror === 'boolean') return mirror;
    if (!automirror) return false;
    if (!videoTrack) return isLocalCam;
    var videoTrackSettings = videoTrack.getSettings();
    var isUsersFrontCamera = 'facingMode' in videoTrackSettings ? isLocalCam && videoTrackSettings.facingMode === 'user' : isLocalCam;
    // only apply mirror effect to user facing camera
    return isUsersFrontCamera;
  }, [automirror, isLocalCam, mirror, videoTrack]);
  /**
   * Handle canplay & picture-in-picture events.
   */
  useEffect(function setupVideoEvents() {
    var video = videoEl.current;
    if (!video) return;
    var playVideo = function playVideo() {
      var promise = video.play();
      if (promise !== undefined) {
        promise.then(function () {
          // All good, playback started.
          video.controls = false;
        })["catch"](function (error) {
          // Auto-play was prevented. Show video controls, so user can play video manually.
          video.controls = true;
          console.warn('Failed to play video', error);
        });
      }
    };
    var handleCanPlay = function handleCanPlay() {
      if (!video.paused) return;
      playVideo();
    };
    var handleEnterPIP = function handleEnterPIP() {
      video.style.transform = 'scale(1)';
    };
    var handleLeavePIP = function handleLeavePIP() {
      video.style.transform = '';
      setTimeout(function () {
        if (video.paused) playVideo();
      }, 100);
    };
    var handleVisibilityChange = function handleVisibilityChange() {
      if (document.visibilityState === 'hidden') return;
      if (!video.paused) return;
      playVideo();
    };
    video.addEventListener('canplay', handleCanPlay);
    video.addEventListener('enterpictureinpicture', handleEnterPIP);
    video.addEventListener('leavepictureinpicture', handleLeavePIP);
    // Videos can be paused if media was played in another app on iOS.
    // Resuming here, when returning back to Daily call.
    document.addEventListener('visibilitychange', handleVisibilityChange);
    return function () {
      video.removeEventListener('canplay', handleCanPlay);
      video.removeEventListener('enterpictureinpicture', handleEnterPIP);
      video.removeEventListener('leavepictureinpicture', handleLeavePIP);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);
  /**
   * Update srcObject.
   */
  useEffect(function updateSrcObject() {
    var video = videoEl.current;
    if (!video || !videoTrack) return;
    if (!MediaStream) {
      console.warn("MediaStream API not available. Can't setup ".concat(type, " for ").concat(sessionId));
      return;
    }
    video.srcObject = new MediaStream([videoTrack]);
    video.load();
    return function () {
      // clean up when unmounted
      video.srcObject = null;
      video.load();
    };
  }, [sessionId, type, videoTrack, videoTrack === null || videoTrack === void 0 ? void 0 : videoTrack.id]);
  /**
   * Add optional event listener for resize event so the parent component
   * can know the video's native aspect ratio.
   */
  useEffect(function reportVideoDimensions() {
    var video = videoEl.current;
    if (!onResize || !video) return;
    var frame;
    function handleResize() {
      if (frame) cancelAnimationFrame(frame);
      frame = requestAnimationFrame(function () {
        var video = videoEl.current;
        if (!video || document.hidden) return;
        var videoWidth = video.videoWidth;
        var videoHeight = video.videoHeight;
        if (videoWidth && videoHeight) {
          onResize === null || onResize === void 0 ? void 0 : onResize({
            aspectRatio: videoWidth / videoHeight,
            height: videoHeight,
            width: videoWidth
          });
        }
      });
    }
    handleResize();
    video.addEventListener('loadedmetadata', handleResize);
    video.addEventListener('resize', handleResize);
    return function () {
      if (frame) cancelAnimationFrame(frame);
      video.removeEventListener('loadedmetadata', handleResize);
      video.removeEventListener('resize', handleResize);
    };
  }, [onResize]);
  return React.createElement("video", _assign({
    autoPlay: true,
    muted: true,
    playsInline: true,
    ref: videoRef,
    "data-local": isLocal,
    "data-mirrored": isMirrored || undefined,
    "data-playable": isPlayable || undefined,
    "data-session-id": sessionId,
    "data-subscribed": subscribedState,
    "data-video-type": type,
    style: _assign(_assign({
      objectFit: fit,
      transform: isMirrored ? 'scale(-1, 1)' : ''
    }, style), isPlayable ? playableStyle : {})
  }, props));
});
DailyVideo.displayName = 'DailyVideo';

var DailyDevicesContext = createContext({
  refreshDevices: function refreshDevices() {
    return Promise.resolve();
  }
});

var generalCameraState = atom('idle');
generalCameraState.debugLabel = jotaiDebugLabel('camera-state');
var generalMicrophoneState = atom('idle');
generalMicrophoneState.debugLabel = jotaiDebugLabel('microphone-state');
var cameraDevicesState = atom([]);
cameraDevicesState.debugLabel = jotaiDebugLabel('camera-devices');
var microphoneDevicesState = atom([]);
microphoneDevicesState.debugLabel = jotaiDebugLabel('microphone-devices');
var speakerDevicesState = atom([]);
speakerDevicesState.debugLabel = jotaiDebugLabel('speaker-devices');
var lastCameraErrorState = atom(null);
lastCameraErrorState.debugLabel = jotaiDebugLabel('last-camera-error');
var DailyDevices = function DailyDevices(_a) {
  var children = _a.children;
  var daily = useDaily();
  /**
   * Refreshes list of available devices using enumerateDevices.
   * Previous device states are kept in place, otherwise states are initialized as 'granted'.
   */
  var refreshDevices = useAtomCallback(useCallback(function (_get, set) {
    return __awaiter(void 0, void 0, void 0, function () {
      var devices, cams_1, mics_1, speakers_1, _a, camera_1, mic_1, speaker_1, mapDevice_1, sortDeviceByLabel_1;
      var _b, _c;
      return __generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            /**
             * Check for legacy browsers.
             */
            if (typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _b === void 0 ? void 0 : _b.getUserMedia) === 'undefined' || typeof ((_c = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.enumerateDevices) === 'undefined') {
              set(generalCameraState, 'not-supported');
              set(generalMicrophoneState, 'not-supported');
              return [2 /*return*/];
            }

            if (!daily) return [2 /*return*/];
            _d.label = 1;
          case 1:
            _d.trys.push([1, 4,, 5]);
            return [4 /*yield*/, daily.enumerateDevices()];
          case 2:
            devices = _d.sent().devices;
            cams_1 = devices.filter(function (d) {
              return d.kind === 'videoinput' && d.deviceId !== '';
            });
            mics_1 = devices.filter(function (d) {
              return d.kind === 'audioinput' && d.deviceId !== '';
            });
            speakers_1 = devices.filter(function (d) {
              return d.kind === 'audiooutput' && d.deviceId !== '';
            });
            return [4 /*yield*/, daily.getInputDevices()];
          case 3:
            _a = _d.sent(), camera_1 = _a.camera, mic_1 = _a.mic, speaker_1 = _a.speaker;
            mapDevice_1 = function mapDevice_1(device, d, prevDevices) {
              var _a, _b;
              return {
                device: d,
                selected: 'deviceId' in device && d.deviceId === device.deviceId,
                state: (_b = (_a = prevDevices.find(function (p) {
                  return p.device.deviceId === d.deviceId;
                })) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'granted'
              };
            };
            sortDeviceByLabel_1 = function sortDeviceByLabel_1(a, b) {
              if (a.device.deviceId === 'default') return -1;
              if (b.device.deviceId === 'default') return 1;
              if (a.device.label < b.device.label) return -1;
              if (a.device.label > b.device.label) return 1;
              return 0;
            };
            set(cameraDevicesState, function (prevCams) {
              return cams_1.filter(Boolean).map(function (d) {
                return mapDevice_1(camera_1, d, prevCams);
              }).sort(sortDeviceByLabel_1);
            });
            set(microphoneDevicesState, function (prevMics) {
              return mics_1.filter(Boolean).map(function (d) {
                return mapDevice_1(mic_1, d, prevMics);
              }).sort(sortDeviceByLabel_1);
            });
            set(speakerDevicesState, function (prevSpeakers) {
              return speakers_1.filter(Boolean).map(function (d) {
                return mapDevice_1(speaker_1, d, prevSpeakers);
              }).sort(sortDeviceByLabel_1);
            });
            return [3 /*break*/, 5];
          case 4:
            _d.sent();
            set(generalCameraState, 'not-supported');
            set(generalMicrophoneState, 'not-supported');
            return [3 /*break*/, 5];
          case 5:
            return [2 /*return*/];
        }
      });
    });
  }, [daily]));
  /**
   * Updates general and specific device states, based on blocked status.
   */
  var updateDeviceStates = useAtomCallback(useCallback(function (get, set) {
    return __awaiter(void 0, void 0, void 0, function () {
      var currentCamState, currentMicState, participants, tracks, camPermissionState, micPermissionState, camPermission, micPermission, awaitingCamAccess, initialCamOff, awaitingMicAccess, initialMicOff;
      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
      return __generator(this, function (_r) {
        switch (_r.label) {
          case 0:
            if (!daily) return [2 /*return*/];
            currentCamState = get(generalCameraState);
            currentMicState = get(generalMicrophoneState);
            participants = daily.participants();
            // Guard against potentially uninitialized local participant
            if (!participants.local) return [2 /*return*/];
            tracks = participants.local.tracks;
            camPermissionState = 'prompt';
            micPermissionState = 'prompt';
            if (!navigator.permissions) return [3 /*break*/, 5];
            _r.label = 1;
          case 1:
            _r.trys.push([1, 4,, 5]);
            return [4 /*yield*/, navigator.permissions.query({
              // @ts-ignore
              name: 'camera'
            })];
          case 2:
            camPermission = _r.sent();
            camPermissionState = camPermission.state;
            return [4 /*yield*/, navigator.permissions.query({
              // @ts-ignore
              name: 'microphone'
            })];
          case 3:
            micPermission = _r.sent();
            micPermissionState = micPermission.state;
            return [3 /*break*/, 5];
          case 4:
            _r.sent();
            return [3 /*break*/, 5];
          case 5:
            awaitingCamAccess = camPermissionState === 'prompt' && ['idle', 'pending'].includes(currentCamState) && tracks.video.state === 'interrupted' && !tracks.video.persistentTrack;
            initialCamOff = ['idle', 'pending'].includes(currentCamState) && !tracks.video.persistentTrack && Boolean((_b = tracks.video.off) === null || _b === void 0 ? void 0 : _b.byUser);
            awaitingMicAccess = micPermissionState === 'prompt' && ['idle', 'pending'].includes(currentMicState) && tracks.audio.state === 'interrupted' && !tracks.audio.persistentTrack;
            initialMicOff = ['idle', 'pending'].includes(currentMicState) && !tracks.audio.persistentTrack && Boolean((_c = tracks.audio.off) === null || _c === void 0 ? void 0 : _c.byUser);
            if ((_e = (_d = tracks.audio) === null || _d === void 0 ? void 0 : _d.blocked) === null || _e === void 0 ? void 0 : _e.byDeviceInUse) {
              set(generalMicrophoneState, 'in-use');
              set(microphoneDevicesState, function (mics) {
                return mics.map(function (m) {
                  return m.selected ? _assign(_assign({}, m), {
                    state: 'in-use'
                  }) : m;
                });
              });
            } else if ((_g = (_f = tracks.audio) === null || _f === void 0 ? void 0 : _f.blocked) === null || _g === void 0 ? void 0 : _g.byDeviceMissing) {
              set(generalMicrophoneState, 'not-found');
            } else if (((_j = (_h = tracks.audio) === null || _h === void 0 ? void 0 : _h.blocked) === null || _j === void 0 ? void 0 : _j.byPermissions) || micPermissionState === 'denied') {
              set(generalMicrophoneState, 'blocked');
            } else if (awaitingMicAccess) {
              set(generalMicrophoneState, 'pending');
            } else if (initialMicOff) {
              set(generalMicrophoneState, 'idle');
            } else {
              set(generalMicrophoneState, 'granted');
              set(microphoneDevicesState, function (mics) {
                return mics.map(function (m) {
                  return m.selected ? _assign(_assign({}, m), {
                    state: 'granted'
                  }) : m;
                });
              });
            }
            if ((_l = (_k = tracks.video) === null || _k === void 0 ? void 0 : _k.blocked) === null || _l === void 0 ? void 0 : _l.byDeviceInUse) {
              set(generalCameraState, 'in-use');
              set(cameraDevicesState, function (cams) {
                return cams.map(function (m) {
                  return m.selected ? _assign(_assign({}, m), {
                    state: 'in-use'
                  }) : m;
                });
              });
            } else if ((_o = (_m = tracks.video) === null || _m === void 0 ? void 0 : _m.blocked) === null || _o === void 0 ? void 0 : _o.byDeviceMissing) {
              set(generalCameraState, 'not-found');
            } else if (((_q = (_p = tracks.video) === null || _p === void 0 ? void 0 : _p.blocked) === null || _q === void 0 ? void 0 : _q.byPermissions) || camPermissionState === 'denied') {
              set(generalCameraState, 'blocked');
            } else if (awaitingCamAccess) {
              set(generalCameraState, 'pending');
            } else if (initialCamOff) {
              set(generalCameraState, 'idle');
            } else {
              set(generalCameraState, 'granted');
              set(cameraDevicesState, function (cams) {
                return cams.map(function (m) {
                  return m.selected ? _assign(_assign({}, m), {
                    state: 'granted'
                  }) : m;
                });
              });
            }
            refreshDevices();
            return [2 /*return*/];
        }
      });
    });
  }, [daily, refreshDevices]));
  useDailyEvent('participant-updated', useCallback(function (ev) {
    if (!ev.participant.local) return;
    updateDeviceStates();
  }, [updateDeviceStates]));
  useDailyEvent('available-devices-updated', refreshDevices);
  useDailyEvent('selected-devices-updated', refreshDevices);
  useDailyEvent('camera-error', useAtomCallback(useCallback(function (_get, set, ev) {
    var _a, _b, _c, _d, _e, _f, _g;
    set(lastCameraErrorState, ev.error);
    switch ((_a = ev.error) === null || _a === void 0 ? void 0 : _a.type) {
      case 'cam-in-use':
        set(generalCameraState, 'in-use');
        break;
      case 'mic-in-use':
        set(generalMicrophoneState, 'in-use');
        break;
      case 'cam-mic-in-use':
        set(generalCameraState, 'in-use');
        set(generalMicrophoneState, 'in-use');
        break;
      case 'not-found':
        if ((_b = ev.error) === null || _b === void 0 ? void 0 : _b.missingMedia.includes('video')) set(generalCameraState, 'not-found');
        if ((_c = ev.error) === null || _c === void 0 ? void 0 : _c.missingMedia.includes('audio')) set(generalMicrophoneState, 'not-found');
        break;
      case 'permissions':
        if ((_d = ev.error) === null || _d === void 0 ? void 0 : _d.blockedMedia.includes('video')) set(generalCameraState, 'blocked');
        if ((_e = ev.error) === null || _e === void 0 ? void 0 : _e.blockedMedia.includes('audio')) set(generalMicrophoneState, 'blocked');
        break;
      case 'constraints':
        if (((_f = ev.error) === null || _f === void 0 ? void 0 : _f.reason) === 'invalid') {
          set(generalCameraState, 'constraints-invalid');
          set(generalMicrophoneState, 'constraints-invalid');
        } else if (((_g = ev.error) === null || _g === void 0 ? void 0 : _g.reason) === 'none-specified') {
          set(generalCameraState, 'constraints-none-specified');
          set(generalMicrophoneState, 'constraints-none-specified');
        }
        break;
      case 'undefined-mediadevices':
        set(generalCameraState, 'undefined-mediadevices');
        set(generalMicrophoneState, 'undefined-mediadevices');
        break;
      case 'unknown':
      default:
        set(generalCameraState, 'unknown');
        set(generalMicrophoneState, 'unknown');
        break;
    }
  }, [])));
  /**
   * Update all device state, when camera is started.
   */
  useDailyEvent('started-camera', useAtomCallback(useCallback(function (_get, set) {
    set(generalCameraState, 'granted');
    set(generalMicrophoneState, 'granted');
    updateDeviceStates();
  }, [updateDeviceStates])));
  return React.createElement(DailyDevicesContext.Provider, {
    value: {
      refreshDevices: refreshDevices
    }
  }, children);
};

var liveStreamingState = atom({
  errorMsg: undefined,
  isLiveStreaming: false,
  layout: undefined
});
liveStreamingState.debugLabel = jotaiDebugLabel('live-streaming');
var DailyLiveStreaming = function DailyLiveStreaming(_a) {
  var children = _a.children;
  useDailyEvent('live-streaming-started', useAtomCallback(useCallback(function (_get, set, ev) {
    set(liveStreamingState, {
      isLiveStreaming: true,
      layout: ev === null || ev === void 0 ? void 0 : ev.layout
    });
  }, [])));
  useDailyEvent('live-streaming-stopped', useAtomCallback(useCallback(function (_get, set) {
    set(liveStreamingState, function (prevState) {
      return _assign(_assign({}, prevState), {
        isLiveStreaming: false,
        layout: undefined
      });
    });
  }, [])));
  useDailyEvent('live-streaming-error', useAtomCallback(useCallback(function (_get, set, ev) {
    set(liveStreamingState, function (prevState) {
      return _assign(_assign({}, prevState), {
        errorMsg: ev.errorMsg
      });
    });
  }, [])));
  useDailyEvent('left-meeting', useAtomCallback(useCallback(function (_get, set) {
    set(liveStreamingState, {
      errorMsg: undefined,
      isLiveStreaming: false,
      layout: undefined
    });
  }, [])));
  return React.createElement(React.Fragment, null, children);
};

var meetingStateState = atom('new');
meetingStateState.debugLabel = jotaiDebugLabel('meeting-state');
var meetingErrorState = atom(null);
meetingErrorState.debugLabel = jotaiDebugLabel('meeting-error');
var nonFatalErrorState = atom(null);
nonFatalErrorState.debugLabel = jotaiDebugLabel('non-fatal-error');
var meetingSessionDataState = atom({
  data: undefined,
  topology: 'none'
});
meetingSessionDataState.debugLabel = jotaiDebugLabel('meeting-session-data');
var DailyMeeting = function DailyMeeting(_a) {
  var children = _a.children;
  var daily = useDaily();
  /**
   * Updates meeting state.
   */
  var updateMeetingState = useAtomCallback(useCallback(function (_get, set) {
    if (!daily) return;
    var meetingState = daily.meetingState();
    set(meetingStateState, meetingState);
    return meetingState;
  }, [daily]));
  useDailyEvent('loading', updateMeetingState);
  useDailyEvent('loaded', updateMeetingState);
  useDailyEvent('joining-meeting', updateMeetingState);
  useDailyEvent('joined-meeting', updateMeetingState);
  useDailyEvent('left-meeting', updateMeetingState);
  useDailyEvent('error', useAtomCallback(useCallback(function (_get, set, ev) {
    set(meetingErrorState, ev);
    updateMeetingState();
  }, [updateMeetingState])));
  useDailyEvent('nonfatal-error', useAtomCallback(useCallback(function (_get, set, ev) {
    set(nonFatalErrorState, ev);
  }, [])));
  /**
   * Updates meeting session state.
   */
  var initMeetingSessionState = useAtomCallback(useCallback(function (_get, set) {
    if (!daily) return;
    set(meetingSessionDataState, daily.meetingSessionState());
  }, [daily]));
  /**
   * Initialize state when joined meeting or setting up the hook.
   */
  useDailyEvent('joined-meeting', initMeetingSessionState);
  /**
   * Update Jotai state whenever meeting session state is updated.
   */
  useDailyEvent('meeting-session-state-updated', useAtomCallback(useCallback(function (_get, set, ev) {
    set(meetingSessionDataState, ev.meetingSessionState);
  }, [])));
  /**
   * Reset Jotai state when meeting ends.
   */
  useDailyEvent('left-meeting', useAtomCallback(useCallback(function (_get, set) {
    set(meetingSessionDataState, {
      data: undefined,
      topology: 'none'
    });
  }, [])));
  /**
   * Reset Jotai state when call instance is destroyed.
   */
  useDailyEvent('call-instance-destroyed', useAtomCallback(useCallback(function (_get, set) {
    set(meetingStateState, 'new');
    set(meetingErrorState, null);
    set(nonFatalErrorState, null);
    set(meetingSessionDataState, {
      data: undefined,
      topology: 'none'
    });
  }, [])));
  return React.createElement(React.Fragment, null, children);
};

var topologyState = atom('none');
topologyState.debugLabel = jotaiDebugLabel('topology');
var networkState = atom('unknown');
var networkStateReasons = atom([]);
// @deprecated
var networkQualityState = atom(100);
networkQualityState.debugLabel = jotaiDebugLabel('network-quality');
// @deprecated
var networkThresholdState = atom('good');
networkThresholdState.debugLabel = jotaiDebugLabel('network-threshold');
var DailyNetwork = function DailyNetwork(_a) {
  var children = _a.children;
  var daily = useDaily();
  var topology = useAtomValue(topologyState);
  var initTopology = useAtomCallback(useCallback(function (_get, set) {
    return __awaiter(void 0, void 0, void 0, function () {
      var topology;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!daily) return [2 /*return*/];
            return [4 /*yield*/, daily.getNetworkTopology()];
          case 1:
            topology = _a.sent();
            if (!topology || (topology === null || topology === void 0 ? void 0 : topology.topology) === 'none') return [2 /*return*/];
            set(topologyState, topology.topology);
            return [2 /*return*/];
        }
      });
    });
  }, [daily]));
  useDailyEvent('joined-meeting', initTopology);
  useDailyEvent('network-connection', useAtomCallback(useCallback(function (_get, set, ev) {
    switch (ev.event) {
      case 'connected':
        if (ev.type === 'peer-to-peer') set(topologyState, 'peer');
        if (ev.type === 'sfu') set(topologyState, 'sfu');
        break;
    }
  }, [])));
  useDailyEvent('network-quality-change', useAtomCallback(useCallback(function (_get, set, ev) {
    set(networkState, function (prevNetworkState) {
      return prevNetworkState !== ev.networkState ? ev.networkState : prevNetworkState;
    });
    set(networkStateReasons, function (prevReasons) {
      var _a;
      var curReasons = (_a = ev.networkStateReasons) !== null && _a !== void 0 ? _a : [];
      return !arraysDeepEqual(prevReasons, curReasons) ? curReasons : prevReasons;
    });
    set(networkQualityState, function (prevQuality) {
      return prevQuality !== ev.quality ? ev.quality : prevQuality;
    });
    set(networkThresholdState, function (prevThreshold) {
      return prevThreshold !== ev.threshold ? ev.threshold : prevThreshold;
    });
  }, [])));
  useDailyEvent('left-meeting', useAtomCallback(useCallback(function (_get, set) {
    set(topologyState, 'none');
    set(networkState, 'unknown');
    set(networkStateReasons, []);
    set(networkQualityState, 100);
    set(networkThresholdState, 'good');
  }, [])));
  useEffect(function () {
    if (!daily || topology !== 'none') return;
    initTopology();
  }, [daily, initTopology, topology]);
  return React.createElement(React.Fragment, null, children);
};

var recordingState = atom({
  isLocalParticipantRecorded: false,
  isRecording: false
});
recordingState.debugLabel = jotaiDebugLabel('recording-state');
var DailyRecordings = function DailyRecordings(_a) {
  var children = _a.children;
  var localSessionId = useLocalSessionId();
  var recordingParticipantIds = useParticipantIds({
    filter: 'record'
  });
  var maybeUpdateRecordingState = useAtomCallback(useCallback(function (get, set, hasRecordingParticipants, isLocalParticipantRecording) {
    var oldState = get(recordingState);
    var s = {
      isLocalParticipantRecorded: oldState.isLocalParticipantRecorded,
      isRecording: oldState.isRecording,
      local: oldState.local,
      type: oldState.type
    };
    var newState = {
      // In case type is local or not set, determine based on recording participants
      isLocalParticipantRecorded: (s === null || s === void 0 ? void 0 : s.type) === 'local' || !(s === null || s === void 0 ? void 0 : s.type) ? hasRecordingParticipants : s.isLocalParticipantRecorded,
      isRecording: (s === null || s === void 0 ? void 0 : s.type) === 'local' || !(s === null || s === void 0 ? void 0 : s.type) ? hasRecordingParticipants : s.isRecording,
      local: ((s === null || s === void 0 ? void 0 : s.type) === 'local' || !(s === null || s === void 0 ? void 0 : s.type)) && hasRecordingParticipants ? isLocalParticipantRecording : s === null || s === void 0 ? void 0 : s.local,
      /**
       * Set type in case recording participants are detected.
       * We only set `record` on participants, when recording type is 'local'.
       */
      type: hasRecordingParticipants ? 'local' : oldState === null || oldState === void 0 ? void 0 : oldState.type
    };
    if (customDeepEqual(s, newState)) return;
    set(recordingState, _assign(_assign({}, s), newState));
  }, []));
  /**
   * Update recording state, whenever amount of recording participants changes.
   */
  useEffect(function () {
    var hasRecordingParticipants = recordingParticipantIds.length > 0;
    var isLocalParticipantRecording = recordingParticipantIds.includes(localSessionId || 'local');
    maybeUpdateRecordingState(hasRecordingParticipants, isLocalParticipantRecording);
  }, [localSessionId, maybeUpdateRecordingState, recordingParticipantIds]);
  useDailyEvent('recording-started', useAtomCallback(useCallback(function (_get, set, ev) {
    var _a;
    var isLocalParticipantRecorded = true;
    switch (ev.type) {
      case 'cloud-beta':
      case 'cloud':
        {
          if (localSessionId && ((_a = ev.layout) === null || _a === void 0 ? void 0 : _a.preset) === 'single-participant' && ev.layout.session_id !== localSessionId) {
            isLocalParticipantRecorded = false;
          }
          break;
        }
    }
    set(recordingState, {
      error: false,
      isLocalParticipantRecorded: isLocalParticipantRecorded,
      isRecording: true,
      layout: ev === null || ev === void 0 ? void 0 : ev.layout,
      local: ev === null || ev === void 0 ? void 0 : ev.local,
      recordingId: ev === null || ev === void 0 ? void 0 : ev.recordingId,
      recordingStartedDate: new Date(),
      startedBy: ev === null || ev === void 0 ? void 0 : ev.startedBy,
      type: ev === null || ev === void 0 ? void 0 : ev.type
    });
  }, [localSessionId])));
  useDailyEvent('recording-stopped', useAtomCallback(useCallback(function (_get, set) {
    set(recordingState, function (prevState) {
      return _assign(_assign({}, prevState), {
        isLocalParticipantRecorded: false,
        isRecording: false
      });
    });
  }, [])));
  useDailyEvent('recording-error', useAtomCallback(useCallback(function (_get, set) {
    set(recordingState, function (prevState) {
      return _assign(_assign({}, prevState), {
        error: true,
        isLocalParticipantRecorded: false,
        isRecording: false
      });
    });
  }, [])));
  useDailyEvent('left-meeting', useAtomCallback(useCallback(function (_get, set) {
    set(recordingState, {
      isLocalParticipantRecorded: false,
      isRecording: false
    });
  }, [])));
  return React.createElement(React.Fragment, null, children);
};

/**
 * Returns a meeting's current state.
 */
var useMeetingState = function useMeetingState() {
  var meetingState = useAtomValue(meetingStateState);
  useDebugValue(meetingState);
  return meetingState;
};

var roomState = atom(null);
roomState.debugLabel = jotaiDebugLabel('room-state');
var DailyRoom = function DailyRoom(_a) {
  var children = _a.children;
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateRoom = useAtomCallback(useCallback(function (_get, set) {
    return __awaiter(void 0, void 0, void 0, function () {
      var room;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!daily || meetingState === 'left-meeting') return [2 /*return*/];
            return [4 /*yield*/, daily.room()];
          case 1:
            room = _a.sent();
            if (room && 'id' in room) {
              set(roomState, room);
            }
            return [2 /*return*/, room];
        }
      });
    });
  }, [daily, meetingState]));
  useDailyEvent('access-state-updated', updateRoom);
  useDailyEvent('left-meeting', useAtomCallback(useCallback(function (_get, set) {
    return function () {
      set(roomState, null);
    };
  }, [])));
  return React.createElement(React.Fragment, null, children);
};

var transcriptionState = atom({
  isTranscribing: false,
  model: 'general',
  language: 'en',
  transcriptions: []
});
transcriptionState.debugLabel = jotaiDebugLabel('transcription-state');
var DailyTranscriptions = function DailyTranscriptions(_a) {
  var children = _a.children;
  useDailyEvent('transcription-started', useAtomCallback(useCallback(function (_get, set, ev) {
    set(transcriptionState, {
      error: false,
      transcriptionStartDate: new Date(),
      isTranscribing: true,
      transcriptions: [],
      endpointing: ev.endpointing,
      extra: ev.extra,
      includeRawResponse: ev.includeRawResponse,
      instanceId: ev.instanceId,
      language: ev.language,
      model: ev.model,
      profanity_filter: ev.profanity_filter,
      punctuate: ev.punctuate,
      redact: ev.redact,
      startedBy: ev.startedBy,
      tier: ev.tier
    });
  }, [])));
  useDailyEvent('transcription-stopped', useAtomCallback(useCallback(function (_get, set, ev) {
    set(transcriptionState, function (prevState) {
      return _assign(_assign({}, prevState), {
        updatedBy: ev.updatedBy,
        isTranscribing: false
      });
    });
  }, [])));
  useDailyEvent('transcription-error', useAtomCallback(useCallback(function (_get, set) {
    set(transcriptionState, function (prevState) {
      return _assign(_assign({}, prevState), {
        error: true,
        isTranscribing: false
      });
    });
  }, [])));
  useDailyEvent('left-meeting', useAtomCallback(useCallback(function (_get, set) {
    set(transcriptionState, function (prevState) {
      return _assign(_assign({}, prevState), {
        isTranscribing: false
      });
    });
  }, [])));
  useDailyEvent('app-message', useAtomCallback(useCallback(function (_get, set, ev) {
    if ((ev === null || ev === void 0 ? void 0 : ev.fromId) === 'transcription') {
      set(transcriptionState, function (prevState) {
        return _assign(_assign({}, prevState), {
          // setting it to true whenever a new message is received
          // as the participants who joined after the transcription-started event
          // won't be knowing if transcription is started or not
          isTranscribing: true,
          transcriptions: __spreadArray(__spreadArray([], __read(prevState.transcriptions), false), [ev.data], false)
        });
      });
    }
  }, [])));
  return React.createElement(React.Fragment, null, children);
};

var defaultOptions = {};
var defaultShouldCreateInstance = function defaultShouldCreateInstance() {
  return true;
};
var defaultProps = {
  options: defaultOptions,
  shouldCreateInstance: defaultShouldCreateInstance
};
/**
 * Helper hook to maintain custom call instances in React codebases.
 */
var useCallInstance = function useCallInstance(type, _a) {
  var _b = _a === void 0 ? defaultProps : _a,
    parentElRef = _b.parentElRef,
    _c = _b.options,
    options = _c === void 0 ? defaultOptions : _c,
    _d = _b.shouldCreateInstance,
    shouldCreateInstance = _d === void 0 ? defaultShouldCreateInstance : _d;
  var _e = __read(useState(null), 2),
    callInstance = _e[0],
    setCallInstance = _e[1];
  /**
   * Holds last used props when callObject instance was created.
   */
  var lastUsedOptions = useRef();
  useEffect(function () {
    /**
     * Call frame instances with a defined parentEl likely pass a ref.
     * Typically a DOM ref is initialized with useRef(null).
     * We'll want to wait until parentEl is defined, meaning that the ref is
     * correctly wired up with a DOM element.
     * Otherwise we'll just check shouldCreateInstance().
     */
    if (type === 'callFrame' && (parentElRef === null || parentElRef === void 0 ? void 0 : parentElRef.current) === null || !shouldCreateInstance()) return;
    function destroyCallInstance(co) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4 /*yield*/, co.destroy()];
            case 1:
              _a.sent();
              return [2 /*return*/];
          }
        });
      });
    }
    /**
     * Once instance is destroyed, nullify callInstance, so a new one can be created.
     */
    var handleDestroyedInstance = function handleDestroyedInstance() {
      /**
       * Setting a timeout makes sure the destruction and creation
       * of call instances happen in separate call stacks.
       * Otherwise there's a risk for duplicate call instances.
       */
      setTimeout(function () {
        return setCallInstance(null);
      }, 0);
    };
    var co = Daily.getCallInstance();
    /**
     * In case a call instance exists outside of this hook instance's knowledge,
     * store it in state.
     */
    if (!callInstance && co && !co.isDestroyed()) {
      co.once('call-instance-destroyed', handleDestroyedInstance);
      setCallInstance(co);
      return;
    }
    /**
     * callInstance exists.
     */
    if (callInstance) {
      /**
       * Props have changed. Destroy current instance, so a new one can be created.
       */
      if (!customDeepEqual(lastUsedOptions.current, options)) {
        destroyCallInstance(callInstance);
      }
      /**
       * Return early.
       */
      return;
    }
    if (!co || co.isDestroyed()) {
      /**
       * callInstance doesn't exist or is destroyed (TODO: Check why getCallInstance() can return a destroyed instance),
       * but should be created.
       * Important to spread props, because createCallObject/createFrame alters the passed object (adds layout and dailyJsVersion).
       */
      switch (type) {
        case 'callFrame':
          co = (parentElRef === null || parentElRef === void 0 ? void 0 : parentElRef.current) ? Daily.createFrame(parentElRef.current, _assign({}, options)) : Daily.createFrame(_assign({}, options));
          break;
        case 'callObject':
          co = Daily.createCallObject(_assign({}, options));
          break;
      }
      lastUsedOptions.current = options;
    }
    setCallInstance(co);
    co.once('call-instance-destroyed', handleDestroyedInstance);
    /**
     * No cleanup phase here, because callObject.destroy() returns a Promise.
     * We can't have asynchronous cleanups in a useEffect.
     * To avoid infinite render loops we compare the props when creating call object instances.
     */
  }, [callInstance, options, parentElRef, shouldCreateInstance, type]);
  return callInstance;
};

/**
 * Helper hook to maintain custom callObject instances in React codebases.
 */
var useCallObject = function useCallObject(props) {
  return useCallInstance('callObject', props);
};

var DailyProvider = function DailyProvider(_a) {
  var children = _a.children,
    jotaiStore = _a.jotaiStore,
    props = __rest(_a, ["children", "jotaiStore"]);
  var eventsMap = useRef({});
  /**
   * Generic event handler to loop through registered event callbacks.
   */
  var handleEvent = useCallback(function (ev) {
    var e_1, _a;
    var _b, _c;
    if (!('action' in ev)) return;
    var event = ev.action;
    var allHandlers = Array.from((_c = (_b = eventsMap.current) === null || _b === void 0 ? void 0 : _b[event]) !== null && _c !== void 0 ? _c : []);
    var priorityHandlers = allHandlers.filter(function (_a) {
      var _b = __read(_a, 1),
        key = _b[0];
      return key < 0;
    });
    var normalHandlers = allHandlers.filter(function (_a) {
      var _b = __read(_a, 1),
        key = _b[0];
      return key > 0;
    });
    var sortedHandlers = __spreadArray(__spreadArray([], __read(priorityHandlers), false), __read(normalHandlers), false);
    try {
      for (var sortedHandlers_1 = __values(sortedHandlers), sortedHandlers_1_1 = sortedHandlers_1.next(); !sortedHandlers_1_1.done; sortedHandlers_1_1 = sortedHandlers_1.next()) {
        var _d = __read(sortedHandlers_1_1.value, 2),
          cb = _d[1];
        cb(ev);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (sortedHandlers_1_1 && !sortedHandlers_1_1.done && (_a = sortedHandlers_1["return"])) _a.call(sortedHandlers_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }, []);
  /**
   * In case events are set up via useDailyEvent before a DailyCall instance is available,
   * we'll register the events whenever daily is set.
   */
  var initEventHandlers = useCallback(function (daily) {
    if (!daily) return;
    Object.keys(eventsMap.current).forEach(function (event) {
      daily.off(event, handleEvent);
      if (!daily.isDestroyed()) {
        daily.on(event, handleEvent);
      }
    });
  }, [handleEvent]);
  var externalCallObject = 'callObject' in props ? props.callObject : null;
  var memoizedOptions = useMemo(function () {
    return 'callObject' in props ? {} : props;
  }, [props]);
  var internalCallObject = useCallObject({
    options: memoizedOptions,
    shouldCreateInstance: useCallback(function () {
      return !('callObject' in props);
    }, [props])
  });
  var callObject = externalCallObject !== null && externalCallObject !== void 0 ? externalCallObject : internalCallObject;
  useEffect(function () {
    if (!callObject) return;
    initEventHandlers(callObject);
  }, [callObject, initEventHandlers]);
  /**
   * Registers event callback.
   */
  var on = useCallback(function (ev, cb, key) {
    var _a, _b;
    if (!eventsMap.current[ev]) {
      eventsMap.current[ev] = new Map();
      if (callObject) {
        /**
         * Make sure only 1 event listener is registered at any time for handleEvent.
         * Otherwise, events sent from daily-js might be handled multiple times.
         */
        callObject.off(ev, handleEvent);
        if (!callObject.isDestroyed()) {
          callObject.on(ev, handleEvent);
        }
      }
    }
    if (!((_a = eventsMap.current[ev]) === null || _a === void 0 ? void 0 : _a.has(key))) {
      (_b = eventsMap.current[ev]) === null || _b === void 0 ? void 0 : _b.set(key, cb);
    }
  }, [callObject, handleEvent]);
  /**
   * Unregisters event callback.
   */
  var off = useCallback(function (ev, key) {
    var _a, _b;
    (_a = eventsMap.current[ev]) === null || _a === void 0 ? void 0 : _a["delete"](key);
    if (((_b = eventsMap.current[ev]) === null || _b === void 0 ? void 0 : _b.size) === 0) {
      callObject === null || callObject === void 0 ? void 0 : callObject.off(ev, handleEvent);
      delete eventsMap.current[ev];
    }
  }, [callObject, handleEvent]);
  return React.createElement(Provider, {
    store: jotaiStore
  }, React.createElement(DailyContext.Provider, {
    value: callObject
  }, React.createElement(DailyEventContext.Provider, {
    value: {
      on: on,
      off: off
    }
  }, React.createElement(DailyRoom, null, React.createElement(DailyMeeting, null, React.createElement(DailyNetwork, null, React.createElement(DailyParticipants, null, React.createElement(DailyRecordings, null, React.createElement(DailyLiveStreaming, null, React.createElement(DailyTranscriptions, null, React.createElement(DailyDevices, null, children)))))))))));
};

/**
 * Returns the participant identified by the given sessionId.
 * @param sessionId  The participant's session_id or "local".
 * @deprecated Use [useParticipantProperty](https://docs.daily.co/reference/daily-react/use-participant-property) instead to only subscribe to required participant properties.
 */
var useParticipant = function useParticipant(sessionId, _a) {
  var _b = _a === void 0 ? {} : _a,
    onParticipantLeft = _b.onParticipantLeft,
    onParticipantUpdated = _b.onParticipantUpdated;
  var participant = useAtomValue(participantState(sessionId));
  useThrottledDailyEvent(['participant-updated', 'participant-left'], useCallback(function (evts) {
    var filteredEvts = evts.filter(function (ev) {
      return ev.participant.session_id === sessionId;
    });
    if (!filteredEvts.length) return;
    filteredEvts.forEach(function (ev) {
      switch (ev.action) {
        case 'participant-updated':
          onParticipantUpdated === null || onParticipantUpdated === void 0 ? void 0 : onParticipantUpdated(ev);
          break;
        case 'participant-left':
          onParticipantLeft === null || onParticipantLeft === void 0 ? void 0 : onParticipantLeft(ev);
          break;
      }
    });
  }, [onParticipantLeft, onParticipantUpdated, sessionId]));
  useDebugValue(participant);
  return participant;
};

/**
 * Returns the most recent participant mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.
 * @deprecated Use [useActiveSpeakerId](https://docs.daily.co/reference/daily-react/use-active-speaker-id) instead.
 */
var useActiveParticipant = function useActiveParticipant(_a) {
  var _b = _a === void 0 ? {} : _a,
    _c = _b.ignoreLocal,
    ignoreLocal = _c === void 0 ? false : _c,
    onActiveSpeakerChange = _b.onActiveSpeakerChange;
  var daily = useDaily();
  var recentActiveId = useAtomValue(activeIdState);
  var _d = __read(useState(''), 2),
    activeId = _d[0],
    setActiveId = _d[1];
  var activeParticipant = useParticipant(activeId);
  useEffect(function () {
    var _a;
    if (!daily) return;
    var local = (_a = daily === null || daily === void 0 ? void 0 : daily.participants()) === null || _a === void 0 ? void 0 : _a.local;
    if (ignoreLocal && recentActiveId === (local === null || local === void 0 ? void 0 : local.session_id)) return;
    // setting activeId as string to avoid passing null to useParticipant hook
    setActiveId(recentActiveId !== null && recentActiveId !== void 0 ? recentActiveId : '');
  }, [daily, ignoreLocal, recentActiveId]);
  useDailyEvent('active-speaker-change', useCallback(function (ev) {
    onActiveSpeakerChange === null || onActiveSpeakerChange === void 0 ? void 0 : onActiveSpeakerChange(ev);
  }, [onActiveSpeakerChange]));
  useDebugValue(activeParticipant);
  return activeParticipant;
};

/**
 * React hook to setup [app-message](https://docs.daily.co/reference/daily-js/events/participant-events#app-message) listeners and
 * to send messages via [sendAppMessage](https://docs.daily.co/reference/daily-js/instance-methods/send-app-message).
 */
var useAppMessage = function useAppMessage(_a) {
  var _b = _a === void 0 ? {} : _a,
    onAppMessage = _b.onAppMessage;
  var daily = useDaily();
  var sendAppMessage = useCallback(function (data, to) {
    if (to === void 0) {
      to = '*';
    }
    if (!daily) return;
    daily.sendAppMessage(data, to);
  }, [daily]);
  var handleAppMessage = useCallback(function (ev) {
    onAppMessage === null || onAppMessage === void 0 ? void 0 : onAppMessage(ev, sendAppMessage);
  }, [onAppMessage, sendAppMessage]);
  useDailyEvent('app-message', handleAppMessage);
  return sendAppMessage;
};

var audioLevelProcessor = "\n    class AudioLevelProcessor extends AudioWorkletProcessor {\n    volume;\n    interval;\n    nextFrame;\n    \n    constructor() {\n      super();\n      this.volume = 0;\n      this.interval = 25;\n      this.nextFrame = this.interval;\n    }\n    \n    get intervalInFrames() {\n      // sampleRate is globally defined in AudioWorklets.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\n      // eslint-disable-next-line no-undef\n      return (this.interval / 1000) * sampleRate;\n    }\n    \n    process(inputList) {\n      const firstInput = inputList[0];\n    \n      if (firstInput.length > 0) {\n        const inputData = firstInput[0];\n        let total = 0;\n    \n        for (let i = 0; i < inputData.length; ++i) {\n          total += Math.abs(inputData[i]);\n        }\n    \n        const rms = Math.sqrt(total / inputData.length);\n        this.volume = Math.max(0, Math.min(1, rms));\n    \n        this.nextFrame -= inputData.length;\n        if (this.nextFrame < 0) {\n          this.nextFrame += this.intervalInFrames;\n          this.port.postMessage({ volume: this.volume });\n        }\n      }\n    \n      return true;\n    }\n    }\n    \n    registerProcessor('audiolevel', AudioLevelProcessor);              \n";
var inlineAudioWorklet = "data:application/javascript;charset=utf8,".concat(encodeURIComponent(audioLevelProcessor));

/**
 * Returns the volume level of a given MediaStreamTrack.
 * @param mediaTrack The MediaStreamTrack to be analysed.
 * @param onVolumeChange The function to execute when the volume changes. Can be used to visualise audio output.
 * @deprecated Use useAudioLevelObserver() instead.
 */
var useAudioLevel = function useAudioLevel(mediaTrack, onVolumeChange) {
  var audioCtx = useRef();
  useEffect(function setupStreamAndStartProcessing() {
    var _this = this;
    // No mediaTrack. Stop immediately.
    if (!mediaTrack) return;
    var AudioCtx = typeof AudioContext !== 'undefined' ? AudioContext : typeof window.webkitAudioContext !== 'undefined' ? window.webkitAudioContext : null;
    // No AudioContext available in browser. Can't measure audio volume.
    if (!AudioCtx) return;
    if (!audioCtx.current) {
      // No audio context initialized. Initializing now.
      audioCtx.current = new AudioCtx();
    }
    var audioContext = audioCtx.current;
    // Audio context could not be initialized. Stopping.
    if (!audioContext) return;
    // No MediaStream API available (e.g. WebRTC disabled)
    if (!MediaStream) return;
    var mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([mediaTrack]));
    var node;
    var gainNode;
    var startProcessing = function startProcessing() {
      return __awaiter(_this, void 0, void 0, function () {
        var e_1;
        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 1,, 6]);
              node = new AudioWorkletNode(audioContext, 'audiolevel');
              gainNode = audioContext.createGain();
              return [3 /*break*/, 6];
            case 1:
              _b.sent();
              _b.label = 2;
            case 2:
              _b.trys.push([2, 4,, 5]);
              return [4 /*yield*/, audioContext.audioWorklet.addModule(inlineAudioWorklet)];
            case 3:
              _b.sent();
              node = new AudioWorkletNode(audioContext, 'audiolevel');
              gainNode = audioContext.createGain();
              return [3 /*break*/, 5];
            case 4:
              e_1 = _b.sent();
              console.error(e_1);
              return [3 /*break*/, 5];
            case 5:
              return [3 /*break*/, 6];
            case 6:
              if (!(node && gainNode)) return [2 /*return*/];
              node.port.onmessage = function (event) {
                var volume = 0;
                if (event.data.volume) volume = event.data.volume;
                if (!node) return;
                onVolumeChange(volume);
              };
              gainNode.gain.value = 0;
              try {
                mediaStreamSource.connect(node).connect(gainNode).connect(audioContext.destination);
              } catch (e) {
                console.warn(e);
              }
              return [2 /*return*/];
          }
        });
      });
    };

    startProcessing();
    return function () {
      node === null || node === void 0 ? void 0 : node.disconnect();
      node = null;
      mediaStreamSource === null || mediaStreamSource === void 0 ? void 0 : mediaStreamSource.disconnect();
    };
  }, [onVolumeChange, mediaTrack]);
};

/**
 * Observes the volume level for a given participant.
 * @param id The session_id of the participant to observe.
 * @param cb The function to execute when the volume changes. Can be used to visualise audio output.
 * @param errorCb Error callback. Called when local audio level observer is not available in browser.
 * @param interval Callbacks will be executed at this freqency. If unspecified, Daily's default frequency is used.
 */
var useAudioLevelObserver = function useAudioLevelObserver(id, cb, errorCb, interval) {
  var daily = useDaily();
  var localSessionId = useLocalSessionId();
  var isLocal = id === localSessionId;
  useDailyEvent('local-audio-level', useCallback(function (ev) {
    if (!isLocal) return;
    cb(ev.audioLevel);
  }, [cb, isLocal]));
  useDailyEvent('remote-participants-audio-level', useCallback(function (ev) {
    if (isLocal) return;
    cb(ev.participantsAudioLevel[id]);
  }, [cb, id, isLocal]));
  useEffect(function maybeStartLocalAudioObserver() {
    if (!daily || daily.isDestroyed() || !isLocal) return;
    if (daily.isLocalAudioLevelObserverRunning()) return;
    try {
      daily.startLocalAudioLevelObserver(interval);
    } catch (_a) {
      errorCb === null || errorCb === void 0 ? void 0 : errorCb('Local audio level observer not supported in this browser');
    }
  }, [daily, errorCb, interval, isLocal]);
  useEffect(function maybeStartRemoteAudioObserver() {
    if (!daily || daily.isDestroyed() || isLocal) return;
    if (daily.isRemoteParticipantsAudioLevelObserverRunning()) return;
    daily.startRemoteParticipantsAudioLevelObserver(interval);
  }, [daily, interval, isLocal]);
};

/**
 * Returns a participant's audio track and state.
 * @param participantId The participant's session_id.
 */
var useAudioTrack = function useAudioTrack(participantId) {
  return useMediaTrack(participantId, 'audio');
};

/**
 * Helper hook to maintain custom callFrame instances in React codebases.
 */
var useCallFrame = function useCallFrame(props) {
  return useCallInstance('callFrame', props);
};

var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;

  // do not edit .js files directly - edit src/index.jst

  fastDeepEqual = function equal(a, b) {
    if (a === b) return true;
    if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b;
  };
  return fastDeepEqual;
}

var fastDeepEqualExports = requireFastDeepEqual();
var deepEqual = /*@__PURE__*/getDefaultExportFromCjs(fastDeepEqualExports);

var CPULoadState = atom({
  state: 'low',
  reason: 'none'
});
CPULoadState.debugLabel = jotaiDebugLabel('cpu-load');
/**
 * Returns the current CPU load as reported by daily-js [cpu-load-change](https://docs.daily.co/reference/daily-js/events/quality-events#cpu-load-change) events
 * and [getCpuLoadStats](https://docs.daily.co/reference/daily-js/instance-methods/get-cpu-load-stats).
 */
var useCPULoad = function useCPULoad(_a) {
  var _b = _a === void 0 ? {} : _a,
    onCPULoadChange = _b.onCPULoadChange;
  var cpu = useAtomValue(CPULoadState);
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateCPULoadState = useAtomCallback(useCallback(function (get, set, cpu) {
    var prev = get(CPULoadState); // Get the current CPU load state
    if (deepEqual(prev, cpu)) return; // Check if the previous state is equal to the current one
    set(CPULoadState, cpu); // Update the state if different
  }, []));
  useEffect(function () {
    var mounted = true;
    if (!daily || daily.isDestroyed() || meetingState !== 'joined-meeting') return;
    daily.getCpuLoadStats().then(function (stats) {
      if (!mounted) return;
      updateCPULoadState({
        state: stats.cpuLoadState,
        reason: stats.cpuLoadStateReason
      });
    });
    return function () {
      mounted = false;
    };
  }, [daily, meetingState, updateCPULoadState]);
  useDailyEvent('cpu-load-change', useCallback(function (ev) {
    updateCPULoadState({
      state: ev.cpuLoadState,
      reason: ev.cpuLoadStateReason
    });
    onCPULoadChange === null || onCPULoadChange === void 0 ? void 0 : onCPULoadChange(ev);
  }, [onCPULoadChange, updateCPULoadState]));
  useDebugValue(cpu);
  return cpu;
};

/**
 * Returns a meeting's last known errors.
 */
var useDailyError = function useDailyError() {
  var meetingError = useAtomValue(meetingErrorState);
  var nonFatalError = useAtomValue(nonFatalErrorState);
  var result = {
    meetingError: meetingError,
    nonFatalError: nonFatalError
  };
  useDebugValue(result);
  return result;
};

/**
 * This hook allows access to information about the user's devices and their state.
 */
var useDevices = function useDevices() {
  var daily = useDaily();
  var camState = useAtomValue(generalCameraState);
  var micState = useAtomValue(generalMicrophoneState);
  var camDevices = useAtomValue(cameraDevicesState);
  var micDevices = useAtomValue(microphoneDevicesState);
  var speakerDevices = useAtomValue(speakerDevicesState);
  var cameraError = useAtomValue(lastCameraErrorState);
  var refreshDevices = useContext(DailyDevicesContext).refreshDevices;
  /**
   * Sets video input device to given deviceId.
   */
  var setCamera = useCallback(function (deviceId) {
    return __awaiter(void 0, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, daily === null || daily === void 0 ? void 0 : daily.setInputDevicesAsync({
              audioDeviceId: null,
              videoDeviceId: deviceId
            })];
          case 1:
            _a.sent();
            return [2 /*return*/];
        }
      });
    });
  }, [daily]);
  /**
   * Sets audio input device to given deviceId.
   */
  var setMicrophone = useCallback(function (deviceId) {
    return __awaiter(void 0, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, daily === null || daily === void 0 ? void 0 : daily.setInputDevicesAsync({
              audioDeviceId: deviceId,
              videoDeviceId: null
            })];
          case 1:
            _a.sent();
            return [2 /*return*/];
        }
      });
    });
  }, [daily]);
  /**
   * Sets audio output device to given deviceId.
   */
  var setSpeaker = useCallback(function (deviceId) {
    return __awaiter(void 0, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, daily === null || daily === void 0 ? void 0 : daily.setOutputDeviceAsync({
              outputDeviceId: deviceId
            })];
          case 1:
            _a.sent();
            return [2 /*return*/];
        }
      });
    });
  }, [daily]);
  var errorStates = ['blocked', 'in-use', 'not-found', 'constraints-invalid', 'constraints-none-specified', 'undefined-mediadevices', 'unknown'];
  var result = {
    /**
     * Most recent error object emitted via [camera-error event](https://docs.daily.co/reference/daily-js/events/meeting-events#camera-error).
     */
    cameraError: cameraError,
    /**
     * A list of the user's camera (videoinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    cameras: camDevices,
    /**
     * The general state for camera access.
     */
    camState: camState,
    /**
     * Holds the currently selected camera.
     */
    currentCam: camDevices.find(function (cam) {
      return cam.selected;
    }),
    /**
     * Holds the currently selected microphone.
     */
    currentMic: micDevices.find(function (mic) {
      return mic.selected;
    }),
    /**
     * Holds the currently selected speaker.
     */
    currentSpeaker: speakerDevices.find(function (speaker) {
      return speaker.selected;
    }),
    /**
     * Indicates that there's an issue with camera devices.
     */
    hasCamError: errorStates.includes(camState),
    /**
     * Indicates that there's an issue with microphone devices.
     */
    hasMicError: errorStates.includes(micState),
    /**
     * A list of the user's microphone (audioinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    microphones: micDevices,
    /**
     * The general state for microphone access.
     */
    micState: micState,
    /**
     * Refreshes the list of devices using [enumerateDevices](https://docs.daily.co/reference/daily-js/instance-methods/enumerate-devices).
     */
    refreshDevices: refreshDevices,
    /**
     * Allows to switch to the camera with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.
     */
    setCamera: setCamera,
    /**
     * Allows to switch to the microphone with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.
     */
    setMicrophone: setMicrophone,
    /**
     * Allows to switch to the speaker with the specified deviceId. Calls [setOutputDevice](https://docs.daily.co/reference/daily-js/instance-methods/set-output-device) internally.
     */
    setSpeaker: setSpeaker,
    /**
     * A list of the user's speaker (audiooutput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    speakers: speakerDevices
  };
  useDebugValue(result);
  return result;
};

var inputSettingsState = atom(null);
inputSettingsState.debugLabel = jotaiDebugLabel('input-settings');
var useInputSettings = function useInputSettings(_a) {
  var _b = _a === void 0 ? {} : _a,
    onError = _b.onError,
    onInputSettingsUpdated = _b.onInputSettingsUpdated;
  var inputSettings = useAtomValue(inputSettingsState);
  var nonFatalError = useDailyError().nonFatalError;
  var daily = useDaily();
  var updateInputSettingsState = useAtomCallback(useCallback(function (_get, set, inputSettings) {
    set(inputSettingsState, inputSettings);
  }, []));
  useEffect(function () {
    if (!daily) return;
    daily.getInputSettings().then(updateInputSettingsState);
  }, [daily, updateInputSettingsState]);
  /**
   * Handle 'input-settings-updated' events.
   */
  useDailyEvent('input-settings-updated', useCallback(function (ev) {
    updateInputSettingsState(ev.inputSettings);
    onInputSettingsUpdated === null || onInputSettingsUpdated === void 0 ? void 0 : onInputSettingsUpdated(ev);
  }, [onInputSettingsUpdated, updateInputSettingsState]));
  /**
   * Handle nonfatal errors of type 'input-settings-error'.
   */
  useDailyEvent('nonfatal-error', useCallback(function (ev) {
    if (ev.type !== 'input-settings-error') return;
    onError === null || onError === void 0 ? void 0 : onError(ev);
  }, [onError]));
  /**
   * Calls daily.updateInputSettings internally.
   */
  var updateInputSettings = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return daily === null || daily === void 0 ? void 0 : daily.updateInputSettings.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var result = {
    errorMsg: (nonFatalError === null || nonFatalError === void 0 ? void 0 : nonFatalError.type) === 'input-settings-error' ? nonFatalError.errorMsg : null,
    inputSettings: inputSettings,
    updateInputSettings: updateInputSettings
  };
  useDebugValue(result);
  return result;
};

/**
 * This hook allows to setup [live streaming events](https://docs.daily.co/reference/daily-js/events/live-streaming-events),
 * as well as starting, stopping and updating live streams.
 *
 * Returns the current live streaming state, incl. the current layout and potential errorMsg.
 */
var useLiveStreaming = function useLiveStreaming(_a) {
  var _b = _a === void 0 ? {} : _a,
    onLiveStreamingError = _b.onLiveStreamingError,
    onLiveStreamingStarted = _b.onLiveStreamingStarted,
    onLiveStreamingStopped = _b.onLiveStreamingStopped,
    onLiveStreamingUpdated = _b.onLiveStreamingUpdated,
    onLiveStreamingWarning = _b.onLiveStreamingWarning;
  var daily = useDaily();
  var state = useAtomValue(liveStreamingState);
  useDailyEvent('live-streaming-started', useCallback(function (ev) {
    onLiveStreamingStarted === null || onLiveStreamingStarted === void 0 ? void 0 : onLiveStreamingStarted(ev);
  }, [onLiveStreamingStarted]));
  useDailyEvent('live-streaming-stopped', useCallback(function (ev) {
    onLiveStreamingStopped === null || onLiveStreamingStopped === void 0 ? void 0 : onLiveStreamingStopped(ev);
  }, [onLiveStreamingStopped]));
  useDailyEvent('live-streaming-updated', useCallback(function (ev) {
    onLiveStreamingUpdated === null || onLiveStreamingUpdated === void 0 ? void 0 : onLiveStreamingUpdated(ev);
  }, [onLiveStreamingUpdated]));
  useDailyEvent('live-streaming-error', useCallback(function (ev) {
    onLiveStreamingError === null || onLiveStreamingError === void 0 ? void 0 : onLiveStreamingError(ev);
  }, [onLiveStreamingError]));
  useDailyEvent('nonfatal-error', useCallback(function (ev) {
    if (ev.type !== 'live-streaming-warning') return;
    onLiveStreamingWarning === null || onLiveStreamingWarning === void 0 ? void 0 : onLiveStreamingWarning(ev);
  }, [onLiveStreamingWarning]));
  var startLiveStreaming = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.startLiveStreaming.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var stopLiveStreaming = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.stopLiveStreaming.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var updateLiveStreaming = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.updateLiveStreaming.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var result = _assign(_assign({}, state), {
    startLiveStreaming: startLiveStreaming,
    stopLiveStreaming: stopLiveStreaming,
    updateLiveStreaming: updateLiveStreaming
  });
  useDebugValue(result);
  return result;
};

/**
 * Returns the [participants() object](https://docs.daily.co/reference/daily-js/instance-methods/participants) for the local user.
 * @deprecated Use [useLocalSessionId](https://docs.daily.co/reference/daily-react/use-local-session-id) instead.
 */
var useLocalParticipant = function useLocalParticipant() {
  var localId = useAtomValue(localIdState);
  var localParticipant = useParticipant(localId);
  useDebugValue(localParticipant);
  return localParticipant;
};

/**
 * Returns a meeting's current session data and topology.
 */
var useMeetingSessionState = function useMeetingSessionState(_a) {
  var _b = _a === void 0 ? {} : _a,
    onError = _b.onError;
  var meetingSessionState = useAtomValue(meetingSessionDataState);
  useDailyEvent('nonfatal-error', useCallback(function (ev) {
    if (ev.type !== 'meeting-session-data-error') return;
    onError === null || onError === void 0 ? void 0 : onError(ev);
  }, [onError]));
  var result = {
    data: meetingSessionState === null || meetingSessionState === void 0 ? void 0 : meetingSessionState.data,
    topology: meetingSessionState === null || meetingSessionState === void 0 ? void 0 : meetingSessionState.topology
  };
  useDebugValue(result);
  return result;
};

/**
 * Returns current information about network quality and topology.
 * Allows to setup event listeners for daily's [network events](https://docs.daily.co/reference/daily-js/events/network-events).
 */
var useNetwork = function useNetwork(_a) {
  var _b = _a === void 0 ? {} : _a,
    onNetworkConnection = _b.onNetworkConnection,
    onNetworkQualityChange = _b.onNetworkQualityChange;
  var daily = useDaily();
  var topology = useAtomValue(topologyState);
  var networkState$1 = useAtomValue(networkState);
  var networkStateReasons$1 = useAtomValue(networkStateReasons);
  var quality = useAtomValue(networkQualityState);
  var threshold = useAtomValue(networkThresholdState);
  useDailyEvent('network-connection', useCallback(function (ev) {
    onNetworkConnection === null || onNetworkConnection === void 0 ? void 0 : onNetworkConnection(ev);
  }, [onNetworkConnection]));
  useDailyEvent('network-quality-change', useCallback(function (ev) {
    onNetworkQualityChange === null || onNetworkQualityChange === void 0 ? void 0 : onNetworkQualityChange(ev);
  }, [onNetworkQualityChange]));
  var getStats = useCallback(function () {
    return __awaiter(void 0, void 0, void 0, function () {
      var newStats;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, daily === null || daily === void 0 ? void 0 : daily.getNetworkStats()];
          case 1:
            newStats = _a.sent();
            return [2 /*return*/, newStats === null || newStats === void 0 ? void 0 : newStats.stats];
        }
      });
    });
  }, [daily]);
  var result = {
    getStats: getStats,
    networkState: networkState$1,
    networkStateReasons: networkStateReasons$1,
    quality: quality,
    threshold: threshold,
    topology: topology
  };
  useDebugValue(result);
  return result;
};

var participantCountsState = atom({
  hidden: 0,
  present: 0
});
participantCountsState.debugLabel = jotaiDebugLabel('participant-counts');
/**
 * Returns participant counts for hidden and present participants.
 */
var useParticipantCounts = function useParticipantCounts(_a) {
  var _b = _a === void 0 ? {} : _a,
    onParticipantCountsUpdated = _b.onParticipantCountsUpdated;
  var daily = useDaily();
  var participantCounts = useAtomValue(participantCountsState);
  var updateCounts = useAtomCallback(useCallback(function (_get, set, counts) {
    set(participantCountsState, counts);
  }, []));
  useDailyEvent('participant-counts-updated', useCallback(function (ev) {
    updateCounts(ev.participantCounts);
    onParticipantCountsUpdated === null || onParticipantCountsUpdated === void 0 ? void 0 : onParticipantCountsUpdated(ev);
  }, [onParticipantCountsUpdated, updateCounts]));
  useEffect(function () {
    if (!daily || daily.isDestroyed()) return;
    updateCounts(daily.participantCounts());
  }, [daily, updateCounts]);
  useDebugValue(participantCounts);
  return participantCounts;
};

/**
 * Returns parsed permissions for a given participant.
 * In case no `sessionId` is passed, the hook returns permissions for the local participant.
 * @param sessionId The participant's session_id (optional)
 */
var usePermissions = function usePermissions(sessionId) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  var localSessionId = useLocalSessionId();
  var permissions = useParticipantProperty(sessionId !== null && sessionId !== void 0 ? sessionId : localSessionId, 'permissions');
  var canSendAudio = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canSend : Boolean((_a = permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === null || _a === void 0 ? void 0 : _a.has('audio'));
  var canSendVideo = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canSend : Boolean((_b = permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === null || _b === void 0 ? void 0 : _b.has('video'));
  var canSendCustomAudio = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canSend : Boolean((_c = permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === null || _c === void 0 ? void 0 : _c.has('customAudio'));
  var canSendCustomVideo = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canSend : Boolean((_d = permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === null || _d === void 0 ? void 0 : _d.has('customVideo'));
  var canSendScreenAudio = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canSend : Boolean((_e = permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === null || _e === void 0 ? void 0 : _e.has('screenAudio'));
  var canSendScreenVideo = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canSend : Boolean((_f = permissions === null || permissions === void 0 ? void 0 : permissions.canSend) === null || _f === void 0 ? void 0 : _f.has('screenVideo'));
  var canAdminParticipants = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin : Boolean((_g = permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin) === null || _g === void 0 ? void 0 : _g.has('participants'));
  var canAdminStreaming = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin : Boolean((_h = permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin) === null || _h === void 0 ? void 0 : _h.has('streaming'));
  var canAdminTranscription = typeof (permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin) === 'boolean' ? permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin : Boolean((_j = permissions === null || permissions === void 0 ? void 0 : permissions.canAdmin) === null || _j === void 0 ? void 0 : _j.has('transcription'));
  var result = {
    canAdminParticipants: canAdminParticipants,
    canAdminStreaming: canAdminStreaming,
    canAdminTranscription: canAdminTranscription,
    canSendAudio: canSendAudio,
    canSendCustomAudio: canSendCustomAudio,
    canSendCustomVideo: canSendCustomVideo,
    canSendScreenAudio: canSendScreenAudio,
    canSendScreenVideo: canSendScreenVideo,
    canSendVideo: canSendVideo,
    hasPresence: permissions === null || permissions === void 0 ? void 0 : permissions.hasPresence,
    permissions: permissions
  };
  useDebugValue(result);
  return result;
};

var participantReceiveSettingsState = atomFamily(function (id) {
  var participantReceiveSettingsAtom = atom({}, function (_get, set, newValue) {
    set(participantReceiveSettingsState(id), newValue);
  });
  participantReceiveSettingsAtom.debugLabel = jotaiDebugLabel("participant-receive-settings-".concat(id));
  return participantReceiveSettingsAtom;
});
/**
 * Allows to read and set receiveSettings.
 * In case receiveSettings for participant specified by id are empty, not set or 'inherit',
 * base receiveSettings will be returned.
 * In case meeting is not in joined state, calls to updateReceiveSettings will be silently ignored.
 */
var useReceiveSettings = function useReceiveSettings(_a) {
  var _b = _a === void 0 ? {} : _a,
    _c = _b.id,
    id = _c === void 0 ? 'base' : _c,
    onReceiveSettingsUpdated = _b.onReceiveSettingsUpdated;
  var _d = __read(useAtom(participantReceiveSettingsState('base')), 1),
    baseSettings = _d[0];
  var _e = __read(useAtom(participantReceiveSettingsState(id)), 1),
    receiveSettings = _e[0];
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateReceiveSettingsState = useAtomCallback(useCallback(function (_get, set, receiveSettings) {
    var e_1, _a;
    var ids = __rest(receiveSettings, []);
    try {
      for (var _b = __values(Object.entries(ids)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2),
          id_1 = _d[0],
          settings = _d[1];
        set(participantReceiveSettingsState(id_1), settings);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (!(id in ids)) {
      participantReceiveSettingsState.remove(id);
    }
  }, [id] // Dependencies
  ));

  useDailyEvent('receive-settings-updated', useCallback(function (ev) {
    updateReceiveSettingsState(ev.receiveSettings);
    onReceiveSettingsUpdated === null || onReceiveSettingsUpdated === void 0 ? void 0 : onReceiveSettingsUpdated(ev);
  }, [onReceiveSettingsUpdated, updateReceiveSettingsState]));
  useEffect(function () {
    if (!daily || daily.isDestroyed()) return;
    daily.getReceiveSettings().then(updateReceiveSettingsState);
  }, [daily, updateReceiveSettingsState]);
  var updateReceiveSettings = useCallback(function () {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily || meetingState !== 'joined-meeting') return;
    (_a = daily === null || daily === void 0 ? void 0 : daily.updateReceiveSettings) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArray([daily], __read(args), false));
  }, [daily, meetingState]);
  var result = {
    receiveSettings: id === 'base' || Object.keys(receiveSettings).length === 0 ? baseSettings : receiveSettings,
    updateReceiveSettings: updateReceiveSettings
  };
  useDebugValue(result);
  return result;
};

var useRecording = function useRecording(_a) {
  var _b = _a === void 0 ? {} : _a,
    onRecordingData = _b.onRecordingData,
    onRecordingError = _b.onRecordingError,
    onRecordingStarted = _b.onRecordingStarted,
    onRecordingStopped = _b.onRecordingStopped;
  var daily = useDaily();
  var state = useAtomValue(recordingState);
  useDailyEvent('recording-started', useCallback(function (ev) {
    onRecordingStarted === null || onRecordingStarted === void 0 ? void 0 : onRecordingStarted(ev);
  }, [onRecordingStarted]));
  useDailyEvent('recording-stopped', useCallback(function (ev) {
    onRecordingStopped === null || onRecordingStopped === void 0 ? void 0 : onRecordingStopped(ev);
  }, [onRecordingStopped]));
  useDailyEvent('recording-error', useCallback(function (ev) {
    onRecordingError === null || onRecordingError === void 0 ? void 0 : onRecordingError(ev);
  }, [onRecordingError]));
  useDailyEvent('recording-data', useCallback(function (ev) {
    onRecordingData === null || onRecordingData === void 0 ? void 0 : onRecordingData(ev);
  }, [onRecordingData]));
  /**
   * Starts the recording with the given optional options.
   */
  var startRecording = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.startRecording.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  /**
   * Stops a recording.
   */
  var stopRecording = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.stopRecording.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  /**
   * Updates a running recording's layout configuration.
   */
  var updateRecording = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.updateRecording.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var result = _assign(_assign({}, state), {
    startRecording: startRecording,
    stopRecording: stopRecording,
    updateRecording: updateRecording
  });
  useDebugValue(result);
  return result;
};

/**
 * Stateful hook to work with room, domain and token configuration for a daily room.
 * Includes room default values.
 */
var useRoom = function useRoom() {
  var room = useAtomValue(roomState);
  useDebugValue(room);
  return room;
};

var useRoomExp = function useRoomExp(_a) {
  var _b, _c, _d, _e, _f, _g;
  var _h = _a === void 0 ? {} : _a,
    onCountdown = _h.onCountdown;
  var localJoinDate = useAtomValue(localJoinDateState);
  var room = useRoom();
  var _j = __read(useState(null), 2),
    ejectDate = _j[0],
    setEjectDate = _j[1];
  useEffect(function () {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var expCandidates = [];
    var ejectAfterElapsed = (_d = (_b = (_a = room === null || room === void 0 ? void 0 : room.tokenConfig) === null || _a === void 0 ? void 0 : _a.eject_after_elapsed) !== null && _b !== void 0 ? _b : (_c = room === null || room === void 0 ? void 0 : room.config) === null || _c === void 0 ? void 0 : _c.eject_after_elapsed) !== null && _d !== void 0 ? _d : 0;
    if (ejectAfterElapsed && localJoinDate) {
      expCandidates.push(localJoinDate.getTime() + 1000 * ejectAfterElapsed);
    }
    if (((_e = room === null || room === void 0 ? void 0 : room.tokenConfig) === null || _e === void 0 ? void 0 : _e.exp) && ((_f = room === null || room === void 0 ? void 0 : room.tokenConfig) === null || _f === void 0 ? void 0 : _f.eject_at_token_exp)) {
      expCandidates.push(room.tokenConfig.exp * 1000);
    }
    if (((_g = room === null || room === void 0 ? void 0 : room.config) === null || _g === void 0 ? void 0 : _g.exp) && ((_h = room === null || room === void 0 ? void 0 : room.config) === null || _h === void 0 ? void 0 : _h.eject_at_room_exp)) {
      expCandidates.push(room.config.exp * 1000);
    }
    var newEjectDate = expCandidates.length > 0 ? new Date(Math.min.apply(Math, __spreadArray([], __read(expCandidates), false))) : new Date(0);
    if (newEjectDate.getTime() === 0) return;
    setEjectDate(function (oldEjectDate) {
      return (oldEjectDate === null || oldEjectDate === void 0 ? void 0 : oldEjectDate.getTime()) !== newEjectDate.getTime() ? newEjectDate : oldEjectDate;
    });
  }, [localJoinDate, (_b = room === null || room === void 0 ? void 0 : room.config) === null || _b === void 0 ? void 0 : _b.eject_after_elapsed, (_c = room === null || room === void 0 ? void 0 : room.config) === null || _c === void 0 ? void 0 : _c.eject_at_room_exp, (_d = room === null || room === void 0 ? void 0 : room.config) === null || _d === void 0 ? void 0 : _d.exp, (_e = room === null || room === void 0 ? void 0 : room.tokenConfig) === null || _e === void 0 ? void 0 : _e.eject_after_elapsed, (_f = room === null || room === void 0 ? void 0 : room.tokenConfig) === null || _f === void 0 ? void 0 : _f.eject_at_token_exp, (_g = room === null || room === void 0 ? void 0 : room.tokenConfig) === null || _g === void 0 ? void 0 : _g.exp]);
  useEffect(function () {
    if (!ejectDate || ejectDate.getTime() === 0) return;
    var interval = setInterval(function () {
      var _a;
      var eject = ((_a = ejectDate === null || ejectDate === void 0 ? void 0 : ejectDate.getTime()) !== null && _a !== void 0 ? _a : 0) / 1000;
      var now = Date.now() / 1000;
      var diff = eject - now;
      if (diff < 0) return;
      var hours = Math.max(0, Math.floor(diff / 3600));
      var minutes = Math.max(0, Math.floor(diff % 3600 / 60));
      var seconds = Math.max(0, Math.floor(diff % 60));
      onCountdown === null || onCountdown === void 0 ? void 0 : onCountdown({
        hours: hours,
        minutes: minutes,
        seconds: seconds
      });
    }, 1000);
    return function () {
      clearInterval(interval);
    };
  }, [ejectDate, onCountdown]);
  var result = {
    ejectDate: ejectDate
  };
  useDebugValue(result);
  return result;
};

/**
 * Returns a participant's screenAudio track and state.
 * @param participantId The participant's session_id.
 */
var useScreenAudioTrack = function useScreenAudioTrack(participantId) {
  return useMediaTrack(participantId, 'screenAudio');
};

/**
 * Returns a participant's screenVideo track and state.
 * @param participantId The participant's session_id.
 */
var useScreenVideoTrack = function useScreenVideoTrack(participantId) {
  return useMediaTrack(participantId, 'screenVideo');
};

var sendSettingsState = atom(null);
sendSettingsState.debugLabel = jotaiDebugLabel('send-settings');
/**
 * Returns the current media send settings and an updater function to change the settings.
 */
var useSendSettings = function useSendSettings(_a) {
  var _b = _a === void 0 ? {} : _a,
    onSendSettingsUpdated = _b.onSendSettingsUpdated;
  var daily = useDaily();
  var _c = __read(useAtom(sendSettingsState), 2),
    sendSettings = _c[0],
    setSendSettings = _c[1];
  useDailyEvent('send-settings-updated', useCallback(function (ev) {
    setSendSettings(ev.sendSettings);
    onSendSettingsUpdated === null || onSendSettingsUpdated === void 0 ? void 0 : onSendSettingsUpdated(ev);
  }, [onSendSettingsUpdated, setSendSettings]));
  var storeSendSettings = useCallback(function (sendSettings) {
    setSendSettings(sendSettings);
  }, [setSendSettings]);
  useEffect(function () {
    if (!daily || daily.isDestroyed()) return;
    storeSendSettings(daily.getSendSettings());
  }, [daily, storeSendSettings]);
  /**
   * Updates the local clients send settings.
   * See https://docs.daily.co/reference/daily-js/instance-methods/update-send-settings for details.
   */
  var updateSendSettings = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return __awaiter(void 0, void 0, void 0, function () {
      var newSendSettings;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, daily === null || daily === void 0 ? void 0 : daily.updateSendSettings.apply(daily, __spreadArray([], __read(args), false))];
          case 1:
            newSendSettings = _a.sent();
            if (!newSendSettings) return [2 /*return*/];
            storeSendSettings(newSendSettings);
            return [2 /*return*/, newSendSettings];
        }
      });
    });
  }, [daily, storeSendSettings]);
  var result = {
    sendSettings: sendSettings,
    updateSendSettings: updateSendSettings
  };
  useDebugValue(result);
  return result;
};

var useTranscription = function useTranscription(_a) {
  var _b = _a === void 0 ? {} : _a,
    onTranscriptionAppData = _b.onTranscriptionAppData,
    onTranscriptionError = _b.onTranscriptionError,
    onTranscriptionMessage = _b.onTranscriptionMessage,
    onTranscriptionStarted = _b.onTranscriptionStarted,
    onTranscriptionStopped = _b.onTranscriptionStopped;
  var daily = useDaily();
  var state = useAtomValue(transcriptionState);
  useDailyEvent('transcription-started', useCallback(function (ev) {
    onTranscriptionStarted === null || onTranscriptionStarted === void 0 ? void 0 : onTranscriptionStarted(ev);
  }, [onTranscriptionStarted]));
  useDailyEvent('transcription-stopped', useCallback(function (ev) {
    onTranscriptionStopped === null || onTranscriptionStopped === void 0 ? void 0 : onTranscriptionStopped(ev);
  }, [onTranscriptionStopped]));
  useDailyEvent('transcription-error', useCallback(function (ev) {
    onTranscriptionError === null || onTranscriptionError === void 0 ? void 0 : onTranscriptionError(ev);
  }, [onTranscriptionError]));
  useDailyEvent('transcription-message', useCallback(function (ev) {
    onTranscriptionMessage === null || onTranscriptionMessage === void 0 ? void 0 : onTranscriptionMessage(ev);
  }, [onTranscriptionMessage]));
  useDailyEvent('app-message', useCallback(function (ev) {
    if ((ev === null || ev === void 0 ? void 0 : ev.fromId) === 'transcription') {
      onTranscriptionAppData === null || onTranscriptionAppData === void 0 ? void 0 : onTranscriptionAppData(ev);
    }
  }, [onTranscriptionAppData]));
  /**
   * Starts the transcription with the given optional options.
   */
  var startTranscription = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.startTranscription.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  /**
   * Stops a transcription.
   */
  var stopTranscription = useCallback(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!daily) return;
    daily.stopTranscription.apply(daily, __spreadArray([], __read(args), false));
  }, [daily]);
  var result = _assign(_assign({}, state), {
    startTranscription: startTranscription,
    stopTranscription: stopTranscription
  });
  useDebugValue(result);
  return result;
};

/**
 * Returns a participant's video track and state.
 * @param participantId The participant's session_id.
 */
var useVideoTrack = function useVideoTrack(participantId) {
  return useMediaTrack(participantId, 'video');
};

/**
 * Hook to access and manage waiting participants.
 */
var useWaitingParticipants = function useWaitingParticipants(_a) {
  var _b = _a === void 0 ? {} : _a,
    onWaitingParticipantAdded = _b.onWaitingParticipantAdded,
    onWaitingParticipantRemoved = _b.onWaitingParticipantRemoved,
    onWaitingParticipantUpdated = _b.onWaitingParticipantUpdated;
  var daily = useDaily();
  var waitingParticipants = useAtomValue(allWaitingParticipantsSelector(undefined));
  useDailyEvent('waiting-participant-added', useCallback(function (ev) {
    onWaitingParticipantAdded === null || onWaitingParticipantAdded === void 0 ? void 0 : onWaitingParticipantAdded(ev);
  }, [onWaitingParticipantAdded]));
  useDailyEvent('waiting-participant-removed', useCallback(function (ev) {
    onWaitingParticipantRemoved === null || onWaitingParticipantRemoved === void 0 ? void 0 : onWaitingParticipantRemoved(ev);
  }, [onWaitingParticipantRemoved]));
  useDailyEvent('waiting-participant-updated', useCallback(function (ev) {
    onWaitingParticipantUpdated === null || onWaitingParticipantUpdated === void 0 ? void 0 : onWaitingParticipantUpdated(ev);
  }, [onWaitingParticipantUpdated]));
  var updateWaitingParticipantAccess = useCallback(function (id, grantRequestedAccess) {
    if (id === '*') {
      daily === null || daily === void 0 ? void 0 : daily.updateWaitingParticipants({
        '*': {
          grantRequestedAccess: grantRequestedAccess
        }
      });
      return;
    }
    daily === null || daily === void 0 ? void 0 : daily.updateWaitingParticipant(id, {
      grantRequestedAccess: grantRequestedAccess
    });
  }, [daily]);
  var grantAccess = useCallback(function (id) {
    updateWaitingParticipantAccess(id, true);
  }, [updateWaitingParticipantAccess]);
  var denyAccess = useCallback(function (id) {
    updateWaitingParticipantAccess(id, false);
  }, [updateWaitingParticipantAccess]);
  var result = {
    waitingParticipants: waitingParticipants,
    grantAccess: grantAccess,
    denyAccess: denyAccess
  };
  useDebugValue(result);
  return result;
};

export { DailyAudio, DailyAudioTrack, DailyProvider, DailyVideo, useActiveParticipant, useActiveSpeakerId, useAppMessage, useAudioLevel, useAudioLevelObserver, useAudioTrack, useCPULoad, useCallFrame, useCallObject, useDaily, useDailyError, useDailyEvent, useDevices, useInputSettings, useLiveStreaming, useLocalParticipant, useLocalSessionId, useMediaTrack, useMeetingSessionState, useMeetingState, useNetwork, useParticipant, useParticipantCounts, useParticipantIds, useParticipantProperty, usePermissions, useReceiveSettings, useRecording, useRoom, useRoomExp, useScreenAudioTrack, useScreenShare, useScreenVideoTrack, useSendSettings, useThrottledDailyEvent, useTranscription, useVideoTrack, useWaitingParticipants };
//# sourceMappingURL=index.esm.js.map
